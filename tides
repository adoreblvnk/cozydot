#!/bin/bash

set -euo pipefail

# constants
readonly DOTFILES="dotfiles"
CONFIG="$(dirname "$0")/configs/default.yaml"
SECRETS="$(dirname "$0")/secrets.yaml"
CONFIG_DIR="$(dirname "$0")/configs"
# set in _set_constants
DISTRO=
DESKTOP_ENVIRONMENT=
DISPLAY_SERVER=

# ----- PRINT FUNCTIONS -----

# Set text colours if supported.
# Arguments:
#   colours enabled, a boolean
_colours() {
  if [[ "$(tput colors)" -ge 8 ]] && [[ $1 == true ]]; then
    NC="$(tput sgr0)" # text reset (select graphic representation default)
    BOLD="$(tput bold)"
    RED="$(tput setaf 1)"            # red
    GREEN="$(tput setaf 2)"          # green
    YELLOW="$(tput setaf 3)"         # yellow
    BLUE="$(tput setaf 4)"           # blue
    MAGENTA="$(tput setaf 5)"        # magenta
    CYAN="$(tput setaf 6)"           # cyan
    B_RED="$(tput bold setaf 1)"     # bold red
    B_GREEN="$(tput bold setaf 2)"   # bold green
    B_YELLOW="$(tput bold setaf 3)"  # bold yellow
    B_BLUE="$(tput bold setaf 4)"    # bold blue
    B_MAGENTA="$(tput bold setaf 5)" # bold magenta
    B_CYAN="$(tput bold setaf 6)"    # bold cyan
    tides_txt="${B_RED}t${B_YELLOW}i${B_GREEN}d${B_BLUE}e${B_MAGENTA}s${NC}"
    TIDES_TXT="${B_RED}T${B_YELLOW}I${B_GREEN}D${B_BLUE}E${B_MAGENTA}S${NC}"
  else
    # don't set colours if argument is false (or not given). use `_colours false` for readability
    NC=
    BOLD=
    RED=
    GREEN=
    YELLOW=
    BLUE=
    MAGENTA=
    CYAN=
    B_RED=
    B_GREEN=
    B_YELLOW=
    B_BLUE=
    B_MAGENTA=
    B_CYAN=
    tides_txt="tides"
    TIDES_TXT="TIDES"
  fi
}

_info_msg() { echo "${B_BLUE}Info:${NC} $1"; }

_success_msg() { echo "${B_GREEN}Success:${NC} $1"; }

_warning_msg() { echo "${B_YELLOW}Warning:${NC} $1"; }

_error_msg() {
  echo "${B_RED}Error:${NC} $1"
  exit 1
}

_usage() {
  cat <<EOF
${TIDES_TXT} (${B_RED}T${NC}he ${B_YELLOW}I${NC}dempotent ${B_GREEN}D${NC}ev ${B_BLUE}E${NC}nvironment ${B_MAGENTA}S${NC}etup) is an automated ${BOLD}post-install${NC}, ${BOLD}update${NC}, & ${BOLD}config (dotfile) manager${NC} for Linux

${YELLOW}Usage:${NC} ${tides_txt} ${CYAN}[Options]${NC} ${CYAN}[Command]${NC}

${YELLOW}Options:${NC}
  ${GREEN}    --no-colour       ${NC} Do not output any colour. Useful when redirecting output to a logfile
  ${GREEN}    --list-configs    ${NC} List all available configs in \$CONFIG_DIR (default: ${BLUE}<tides_path>/configs/${NC})
                         directory
  ${GREEN}-c, --config <CONFIG> ${NC} Set a config file that exists in \$CONFIG_DIR (default: ${BLUE}<tides_path>/configs/${NC})
                         directory
  ${GREEN}    --secrets <SECRET>${NC} Set a secrets file. Add to ${BLUE}.gitignore${NC} if secrets file is in ${tides_txt} directory
  ${GREEN}-h, --help            ${NC} Print help information
  ${GREEN}-V, --version         ${NC} Print version information

${YELLOW}Commands:${NC}

  ${GREEN}   check    ${NC} Purges bloat (default) & installs dependencies. Installs Python (via pyenv), Cargo
               (via rustup), fonts (Geist & Nerdfonts), & firmware packages
  ${GREEN}i, install  ${NC} Installs all apt (& alternative sources), flatpak, cargo, & binary (AppImage) 
               packages
  ${GREEN}u, update   ${NC} Updates & upgrades apt, flatpak, cargo packages. Updates other packages & cleans
               system (see \`${BLUE}config.yaml${NC}\` for details)
  ${GREEN}c, configure${NC} Configures apps installed, restore / backup dotfiles via Stow (dotfile manager), & 
               performs other system configs.
  ${GREEN}h, help     ${NC} Print help information

${YELLOW}Configuration:${NC}
  Customise the actions each command by modifying the ${BLUE}configs/default.yaml${NC} file.
  The full config schema of ${tides_txt} is available at ${BLUE}README.md${NC}.
  Preset configs are available in ${BLUE}<tides_path>/configs/${NC} directory. Add new configs in \$CONFIG_DIR
   (default: ${BLUE}<tides_path>/configs/${NC}) & list them with ${tides_txt} ${CYAN}--list-configs${NC}

${YELLOW}Example:${NC}
  ${tides_txt} ${CYAN}--config${NC} virtual_machine ${CYAN}configure${NC}

${YELLOW}Project Homepage:${NC} ${MAGENTA}https://github.com/adoreblvnk/tides${NC}

EOF
}

# ----- SET CONSTANTS -----

# Set complex constants that require commands to be set.
# Globals:
#   EDIT
#   DISTRO
#   DESKTOP_ENVIRONMENT
#   VERSION_CODENAME: only if $UBUNTU_CODENAME exists
_set_constants() {
  EDIT=$(yq '.metadata.edit' "$CONFIG") # enables config file editing

  # get distro & set $DISTRO
  . /etc/os-release # contains operating system identification data
  DISTRO="$(yq '.metadata.distro' "$CONFIG")"
  if [[ $DISTRO == "auto" ]]; then
    DISTRO="$ID" # TODO: create var to store upstream distro?
    case "$DISTRO" in
      # https://github.com/which-distro/os-release
      ubuntu | linuxmint | pop | zorin | Deepin) ;;
      debian | kali | tails)
        # TODO: add debian support
        _warning_msg "Debian distros not supported yet"
        ;;
      *) _error_msg "Unsupported distro detected" ;;
    esac
    _info_msg "Auto-detected & set distro to $DISTRO"
  else
    _info_msg "Set distro to $DISTRO as manually specified in config"
  fi

  if [[ -n $UBUNTU_CODENAME ]]; then
    _info_msg "Ubuntu-based distro detected. overwriting \$VERSION_CODENAME to $UBUNTU_CODENAME"
    # overwrite $VERSION_CODENAME for adding repos which use $VERSION_CODENAME in config. Modifying
    # this system variable has no major consequences anyways
    # shellcheck disable=SC2034
    VERSION_CODENAME=$UBUNTU_CODENAME
  fi

  # get desktop environment & set $DESKTOP_ENVIRONMENT
  DESKTOP_ENVIRONMENT="$(yq '.metadata.desktopEnvironment' "$CONFIG")"
  # detect DE modified from https://cgit.freedesktop.org/xdg/xdg-utils/tree/scripts/xdg-utils-common.in#n296
  if [[ $DESKTOP_ENVIRONMENT == "auto" ]]; then
    case "$XDG_CURRENT_DESKTOP" in
      Cinnamon | X-Cinnamon) DESKTOP_ENVIRONMENT=cinnamon ;;
      *GNOME*) DESKTOP_ENVIRONMENT=gnome ;;
      *) _warning_msg "Unknown desktop environment" ;;
    esac
    if [[ $DESKTOP_ENVIRONMENT != "auto" ]]; then
      _info_msg "Auto-detected & set desktop environment to $DESKTOP_ENVIRONMENT"
    fi
  else
    _info_msg "Set desktop environment to $DESKTOP_ENVIRONMENT as manually specified in config"
  fi

  # get & set $DISPLAY_SERVER
  DISPLAY_SERVER="$(yq '.metadata.displayServer' "$CONFIG")"
  if [[ $DISPLAY_SERVER == "auto" ]]; then
    case "$XDG_SESSION_TYPE" in
      x11) DISPLAY_SERVER=x11 ;;
      wayland) DISPLAY_SERVER=wayland ;;
      *) _warning_msg "Unknown display server" ;;
    esac
    if [[ $DISPLAY_SERVER != "auto" ]]; then
      _info_msg "Auto-detected & set display server to $DISPLAY_SERVER"
    fi
  else
    _info_msg "Set display server to $DISPLAY_SERVER as manually specified in config"
  fi

}

# ----- OPTIONS -----

list_configs() {
  local configs
  # find all preset files, then filter out the parent dirs & file suffixes
  mapfile -t configs < <(
    find "$CONFIG_DIR" -type f | awk -F '[/.]' '{print $--NF}'
  )
  echo "${YELLOW}Available configs:${NC}"
  for config in "${configs[@]}"; do
    echo "  ${GREEN}$config${NC}"
  done
}

# Use config specified in config directory.
# Arguments:
#   config that exists in $CONFIG_DIR
set_config() {
  local config_file="${CONFIG_DIR}/$1.yaml"
  if [[ -f $config_file ]]; then
    _info_msg "Using $1 config (${config_file})"
    CONFIG=$config_file
  else
    _error_msg "Config selected \"$1\" does not exist"
  fi
}

# Use secrets file specified by user.
# Arguments:
#   secrets file as a path
set_secrets_file() {
  SECRETS="$(realpath "$1")"
  if [[ -f "$SECRETS" ]]; then
    yq '.gitconfig.name' "$SECRETS"
  else
    _error_msg "Secrets file selected \"$1\" does not exist"
  fi
}

get_version() { echo "${tides_txt} $(yq '.version' "$CONFIG")"; }

# ----- COMMANDS -----

check() {
  _info_msg "Starting ${tides_txt} check..."

  _set_constants

  if [[ $(yq '.config.check.snapDisabled' "$CONFIG") == true ]]; then
    _info_msg "Disabling snap"

    if command -v snap &>/dev/null; then
      _info_msg "Removing snap packages"
      mapfile -t snap_pkgs < <(
        snap list | grep -Ev '^(Name|bare|core[0-9][0-9]|snapd\s)' \
          | awk '{print $1}'
      )
      for pkg in "${snap_pkgs[@]}"; do
        # shellcheck disable=SC2086
        snap remove --purge $pkg
      done
      snap remove --purge "$(snap list | grep -o '^core[0-9][0-9]')"
      snap remove --purge bare
      snap remove --purge snapd
    fi

    if systemctl -q is-active snapd; then
      _info_msg "Stop & disable snap services"
      sudo systemctl stop snapd
      sudo systemctl disable snapd
    fi

    if command -v snapd &>/dev/null; then
      _info_msg "Removing snapd package from apt"
      sudo apt-get remove --purge -qq snapd
    fi

    if [[ -d ~/snap ]]; then
      _info_msg "Removing snap package directories"
      rm -rf ~/snap
    fi

    if [[ -d /snap || -d /var/snap || -d /var/lib/snapd ]]; then
      _info_msg "Removing leftover snap directories"
      sudo rm -rf /snap /var/snap /var/lib/snapd
    fi

    if [[ ! -f /etc/apt/preferences.d/nosnap.pref ]]; then
      _info_msg "Creating nosnap.pref to prevent snap from being reinstalled"
      sudo tee /etc/apt/preferences.d/nosnap.pref <<EOF >/dev/null
Package: snapd
Pin: release a=*
Pin-Priority: -10
EOF
    fi
  fi

  if [[ $(yq '.config.check.purge | tag' "$CONFIG") == "!enabled" ]]; then
    _info_msg "Purging apt packages"

    local purge_pkgs # collect purge packages into array
    mapfile -t purge_pkgs < <(yq '.config.check.purge[]' "$CONFIG")
    for pkg in "${purge_pkgs[@]}"; do
      # shellcheck disable=SC2086
      sudo apt-get autoremove --purge -qy $pkg
    done

    if $EDIT; then
      _info_msg "Disabling purge"
      yq -i '.config.check.purge tag = "!disabled"' "$CONFIG"
    fi
  fi

  # install dependency packages
  if [[ $(yq '.config.check.deps | tag' "$CONFIG") == "!enabled" ]]; then
    local apt_pkgs
    mapfile -t apt_pkgs < <(yq '.config.check.deps[]' "$CONFIG")
    sudo apt-get update -qq
    for pkg in "${apt_pkgs[@]}"; do
      _info_msg "Installing dependency $pkg"
      sudo apt-get install -qq "$pkg"
    done

    if $EDIT; then
      _info_msg "Disabling dependency installation"
      yq -i '.config.check.deps tag = "!disabled"' "$CONFIG"
    fi
  fi

  # installs pyenv, installs python according to version specified in $CONFIG
  if [[ $(yq '.config.check.python | tag' "$CONFIG") == "!enabled" ]]; then
    if ! command -v pyenv &>/dev/null; then
      _info_msg "Installing pyenv"
      if [[ ! -d ~/.pyenv ]]; then
        # NOTE: if pyenv dir exists but pyenv command fails, this means that pyenv isn't in PATH
        # install pyenv-installer https://github.com/pyenv/pyenv-installer &:
        #   - pyenv https://github.com/pyenv/pyenv
        #   - pyenv-doctor https://github.com/pyenv/pyenv-doctor
        #   - pyenv-update https://github.com/pyenv/pyenv-update
        #   - pyenv-virtualenv https://github.com/pyenv/pyenv-virtualenv
        curl https://pyenv.run | bash
      fi

      _info_msg "Temporarily exporting pyenv into PATH"
      export PATH="$HOME/.pyenv/bin:$PATH"
      eval "$(pyenv init -)"
      eval "$(pyenv virtualenv-init -)"
    else
      if [[ $(yq '.config.check.python.pyenvUpdate' "$CONFIG") == true ]]; then
        pyenv update 2>/dev/null
      fi
      _info_msg "pyenv $(pyenv --version | cut -d ' ' -f 2) is already installed"
    fi

    # install latest python version if pyenv python version is not latest.
    local latest_py_ver=$(pyenv latest -k "$(yq '.config.check.python.version' "$CONFIG")")
    if [[ $(pyenv version-name) != "$latest_py_ver" ]]; then
      # only install if python version exists but is not set to global
      if ! pyenv versions | grep "$latest_py_ver"; then
        _info_msg "Installing latest Python version $latest_py_ver"
        pyenv install "$(yq '.config.check.python.version' "$CONFIG")"
      fi
      _info_msg "Setting global Python version to $latest_py_ver"
      pyenv global "$(yq '.config.check.python.version' "$CONFIG")"
    else
      _info_msg "Python $(pyenv version-name) is already the latest version"
    fi

    if [[ $(yq '.config.check.python.pip' "$CONFIG") == true ]]; then
      local py_ver="python$(yq '.config.check.python.version' "$CONFIG")"
      _info_msg "Installing / upgrading pip"
      $py_ver -m pip install --upgrade pip
      _info_msg "Pip version $($py_ver -m pip -V | cut -d ' ' -f 2) installed"
    fi
  fi

  if [[ $(yq '.config.check.rustupCheck' "$CONFIG") == true ]] \
    && ! command -v rustup &>/dev/null; then
    _info_msg "Installing Rustup toolchain (rustup, rustc, cargo)"
    curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y
  elif [[ $(yq '.config.check.rustupCheck' "$CONFIG") == true ]]; then
    _info_msg "Rustup $(rustup -V 2>/dev/null | cut -d ' ' -f 2) toolchain already installed"
  fi

  # setup appimaged if appimaged service isn't running or appimage.cleanInstall is specified
  if [[ $(yq '.config.check.appimaged | tag' "$CONFIG") == "!enabled" ]] \
    && { ! systemctl --user -q is-active appimaged \
      || [[ $(yq '.config.check.appimaged.cleanInstall' "$CONFIG") == true ]]; }; then
    _info_msg "Installing appimaged"
    # https://github.com/probonopd/go-appimage/tree/master/src/appimaged#initial-setup

    # remove pre-existing similar tools
    systemctl --user stop appimaged.service || true
    sudo apt-get remove -qy appimagelauncher || true

    # clear cache
    rm -rf "$HOME/.local/share/applications/appimage*"
    [ -f ~/.config/systemd/user/default.target.wants/appimagelauncherd.service ] \
      && rm ~/.config/systemd/user/default.target.wants/appimagelauncherd.service

    # download appimaged
    mkdir -p "$HOME/Applications"
    # get continuous release via GitHub api
    local browser_download_url=$(
      curl -sSL https://api.github.com/repos/probonopd/go-appimage/releases/tags/continuous \
        | yq '.assets[].browser_download_url | select(. == "*appimaged*x86_64.AppImage")'
    )
    curl -sSL -o "$HOME/Applications/appimaged.AppImage" \
      "$browser_download_url"

    # launch
    chmod +x "$HOME/Applications/appimaged.AppImage"
    "$HOME/Applications/appimaged.AppImage"
  elif [[ $(yq '.config.check.appimaged | tag' "$CONFIG") == "!enabled" ]]; then
    _info_msg "Appimaged service already running"
  fi

  # install Geist font
  if [[ $(yq '.config.check.geistFontEnabled' "$CONFIG") == true ]]; then
    _info_msg "Geist font check"
    if [[ ! -d "/usr/share/fonts/opentype/Geist/" ]]; then
      _info_msg "Downloading & installing Geist font"
      local font_url=$(
        curl -sSL https://api.github.com/repos/vercel/geist-font/releases/latest \
          | yq -p=j '.assets[].browser_download_url | select(. =="*Geist-*")'
      )
      # download Geist font
      curl -sSL -o Geist.zip "$font_url"
      unzip -o Geist.zip
      # install Geist opentype font
      sudo mv Geist-*/statics-otf/ /usr/share/fonts/opentype/Geist/
      _info_msg "Cleanup remnant files"
      rm -rf Geist.zip __MACOSX/ Geist-*
    else
      _info_msg "Geist font already exists"
    fi
    _info_msg "Reloading fc-cache"
    fc-cache -f

    if $EDIT; then
      _info_msg "Disabling geistFont"
      yq -i '.config.check.geistFont tag = "!disabled"' "$CONFIG"
    fi
  fi

  # install nerdfont
  if [[ $(yq '.config.check.nerdfont | tag' "$CONFIG") == "!enabled" ]]; then
    local font=$(yq '.config.check.nerdfont' "$CONFIG")
    _info_msg "Installing nerdfont $font"
    if [[ ! -d "/usr/share/fonts/$font" ]]; then
      _info_msg "Downloading $font"
      sudo mkdir -p "/usr/share/fonts/$font"
      curl -sSL \
        "https://github.com/ryanoasis/nerd-fonts/releases/latest/download/$font.tar.xz" \
        | sudo tar -xvJ -C "/usr/share/fonts/$font"
    else
      _info_msg "$font already exists"
    fi
    _info_msg "Reloading fc-cache"
    fc-cache -f

    if $EDIT; then
      _info_msg "Disabling nerdfont"
      yq -i '.config.check.nerdfont tag = "!disabled"' "$CONFIG"
    fi
  fi
}

install() {
  _info_msg "Starting ${tides_txt} install"

  if [[ $(yq '.config.install.check' "$CONFIG") == true ]]; then
    check
  else
    _set_constants
  fi

  # install apt packages
  if [[ $(yq '.config.install.apt | tag' "$CONFIG") == "!enabled" ]]; then
    local apt_pkgs
    mapfile -t apt_pkgs < <(yq '.config.install.apt[]' "$CONFIG")
    sudo apt-get update -qq
    for pkg in "${apt_pkgs[@]}"; do
      _info_msg "Installing $pkg"
      sudo apt-get install -qq "$pkg"
    done
  fi

  # install from 3rd-party repos
  if [[ $(yq '.config.install.addRepos | tag' "$CONFIG") == "!enabled" ]]; then
    _info_msg "Installing apt packages from third party repositories"

    # setting up signing keys & repo entries for source (repo)
    for ((i = 0; i < $(yq '.config.install.addRepos | length' "$CONFIG"); i++)); do
      local pkg_map=$(yq ".config.install.addRepos[$i]" "$CONFIG")
      local source_name=$(yq '.sourceName' <<<"$pkg_map")

      # download asc key from remote
      if [[ $(yq '.gpgKeyPath' <<<"$pkg_map") == *.asc ]]; then
        _info_msg "Downloading .asc key for $source_name"
        sudo curl -fsSL -o "$(yq '.gpgKeyPath' <<<"$pkg_map")" \
          "$(yq '.remoteGpgKey' <<<"$pkg_map")"
      # if key is in gpg format, then dearmor after downloading the key
      elif [[ $(yq '.gpgKeyPath' <<<"$pkg_map") == *.gpg ]]; then
        _info_msg "Downloading & dearmoring .gpg key for $source_name"
        sudo curl -fsSL "$(yq '.remoteGpgKey' <<<"$pkg_map")" \
          | sudo gpg --dearmor --yes -o "$(yq '.gpgKeyPath' <<<"$pkg_map")"
      else
        _error_msg "Unsupported apt key format ($(yq '.gpgKeyPath' <<<"$pkg_map")) for $source_name source"
      fi

      # add repo entry into sources.list.d
      local source_file_path="/etc/apt/sources.list.d/$source_name.list"
      _info_msg "Adding repo entry for $source_name into sources.list.d"
      eval echo "$(yq '.repo' <<<"$pkg_map")" \
        | sudo tee "$source_file_path" >/dev/null

      # perform pinning if pinning entry exists
      if [[ $(yq '.pinning' <<<"$pkg_map") != false ]]; then
        _info_msg "Performing pinning to prioritise $source_name"
        # perform pinning to prioritise
        local pref_file="/etc/apt/preferences.d/$source_name"
        yq '.pinning' <<<"$pkg_map" \
          | sudo tee "$pref_file" >/dev/null
      fi
    done

    # install packages
    local apt_pkgs
    mapfile -t apt_pkgs < <(yq '.config.install.addRepos[].packages[]' "$CONFIG")
    sudo apt-get update -qq
    for pkg in "${apt_pkgs[@]}"; do
      _info_msg "Installing third party package $pkg"
      sudo apt-get install -qq "$pkg"
    done
  fi

  # install flatpaks if flatpak is installed
  if [[ $(yq '.config.install.flatpak | tag' "$CONFIG") == "!enabled" ]] \
    && command -v flatpak &>/dev/null; then
    _info_msg "Installing flatpak packages"
    if ! flatpak remotes | grep -iq "^flathub"; then
      _info_msg "Adding flathub repository"
      flatpak remote-add \
        --if-not-exists flathub https://dl.flathub.org/repo/flathub.flatpakrepo
    fi
    # shellcheck disable=SC2046
    flatpak install -y flathub $(yq '.config.install.flatpak[]' "$CONFIG")
  fi

  # install cargo packages if cargo is installed
  if [[ $(yq '.config.install.cargo | tag' "$CONFIG") == "!enabled" ]] \
    && command -v cargo &>/dev/null; then
    _info_msg "Installing cargo packages"
    local rust_pkgs
    mapfile -t rust_pkgs < <(yq '.config.install.cargo[]' "$CONFIG")
    for pkg in "${rust_pkgs[@]}"; do
      # disable SC2086 to enable installing with options
      # shellcheck disable=SC2086
      cargo install $pkg
    done
  fi

  # install binary packages
  if [[ $(yq '.config.install.binaries | tag' "$CONFIG") == "!enabled" ]]; then
    _info_msg "Installing binary packages"
    mkdir -p "$HOME/Applications"
    for ((i = 0; i < "$(yq '.config.install.binaries | length' "$CONFIG")"; i++)); do
      local binary_map=$(yq ".config.install.binaries[$i]" "$CONFIG")
      local binary_name=$(yq '.name' <<<"$binary_map")
      # skip if binary / command (for .deb) exists
      if [[ -f "$HOME/Applications/$binary_name" ]] \
        || command -v "$(head -c '-5' <<<"$binary_name")" &>/dev/null; then
        _info_msg "$binary_name already exists"
        continue
      fi

      # downloading binary from url
      _info_msg "Downloading $binary_name"
      local download_url="$(yq '.url' <<<"$binary_map")"
      # execute download_url string as subshell if subshell detected
      grep -Eq '\$\(.*\)' <<<"$(yq '.url' <<<"$binary_map")" \
        && download_url="$(eval echo "$(yq '.url' <<<"$binary_map")")"
      curl -fsSL -o "$HOME/Applications/$binary_name" "$download_url"

      # install binary (AppImage / deb package)
      _info_msg "Installing $binary_name"
      if [[ $binary_name == *.AppImage ]]; then
        chmod +x "$HOME/Applications/$binary_name"
      elif [[ $binary_name == *.deb ]]; then
        sudo apt-get install -qq "$HOME/Applications/$binary_name"
        rm -f "$HOME/Applications/$binary_name"
      else
        _warning_msg "Unsupported package: $binary_name"
        _error_msg "${tides_txt} currently supports AppImage / deb packages only"
      fi
    done
  fi

  _success_msg "Finished ${tides_txt} install"
}

update() {
  _info_msg "Starting ${tides_txt} update"

  if [[ $(yq '.config.update.check' "$CONFIG") == true ]]; then
    check
  else
    _set_constants
  fi

  if [[ $(yq '.config.update.apt | tag' "$CONFIG") == "!enabled" ]]; then
    _info_msg "Updating & upgrading apt packages"
    sudo apt-get -qq update
    sudo apt-get -qy upgrade
    # aptFull upgrades the entire system, installing new packages if necessary, & removes old
    # archive files & unused packages with their config files
    if [[ $(yq '.config.update.apt.aptFull' "$CONFIG") == true ]]; then
      _info_msg "Performing a full upgrade & removing uneeded packages & apt cache"
      sudo apt-get -qy dist-upgrade
      sudo apt-get -qy autoclean
      sudo apt-get -qy --purge autoremove
    fi
  fi

  # update flatpak
  if [[ $(yq '.config.update.flatpak' "$CONFIG") == true ]] \
    && command -v flatpak &>/dev/null; then
    _info_msg "Updating flatpaks"
    flatpak update -y
  fi

  # update rustup & cargo
  if [[ $(yq '.config.update.cargo' "$CONFIG") == true ]] \
    && command -v rustup &>/dev/null \
    && command -v cargo &>/dev/null; then
    _info_msg "Updating rustup $(rustup -V 2>/dev/null | cut -d ' ' -f 2) & cargo $(cargo -V | cut -d ' ' -f 2) packages"
    rustup update 2>/dev/null
    # install cargo-update package if not installed
    cargo install --list | grep -q "^cargo-update" \
      || cargo install cargo-update
    cargo install-update -a
  fi

  # update yq
  if [[ $(yq '.config.update.other.yq' "$CONFIG") == true ]]; then
    local_yq_ver=$(yq -V | cut -d ' ' -f 4)
    # get latest yq version
    latest_yq_ver=$(
      curl -sSL https://api.github.com/repos/mikefarah/yq/releases/latest \
        | yq '.tag_name'
    )
    if [[ $local_yq_ver != "$latest_yq_ver" ]]; then
      _info_msg "Downloading & installing latest yq (version $latest_yq_ver)"
      sudo curl -sSL -o /usr/bin/yq \
        https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
      sudo chmod +x /usr/bin/yq
    else
      _info_msg "yq $local_yq_ver is already the latest version"
    fi
  fi

  # zellij delete all other sessions, including exited ones
  if [[ $(yq '.config.update.other.zellijClear' "$CONFIG") == true ]] \
    && command -v zellij &>/dev/null; then
    _info_msg "Deleting all other Zellij sessions"
    zellij delete-all-sessions -y
  fi

  _success_msg "Finished ${tides_txt} update"
}

configure() {
  _info_msg "Starting ${tides_txt} configuration"

  if [[ $(yq '.config.configure.check' "$CONFIG") == true ]]; then
    check
  else
    _set_constants
  fi

  # dotfile manager implementation via Stow
  if [[ $(yq '.config.configure.dotfiles | tag' "$CONFIG") == "!enabled" ]] \
    && command -v stow &>/dev/null; then
    _info_msg "Configuring dotfiles via Stow"
    local packages
    mapfile -t packages < <(
      yq -r '.config.configure.dotfiles.packages[]' "$CONFIG"
    )
    for pkg in "${packages[@]}"; do
      _info_msg "Stowing dotfiles for $pkg"
      # symlink between tides & actual dotfiles
      #   --no-folding stows individual files instead of directories
      #   --adopt replaces tides' dotfiles with original system ones
      #    this is needed as Stow throws an error if there are existing system dotfiles
      #    this results in tides' dotfiles being lost, but this is mitigated by setting
      #    .config.configure.stowMode to "override".
      stow --no-folding --adopt -v -d "dotfiles/" -t "$HOME" "$pkg"
      # override option overrides system files with tides' dotfiles pre-replacement
      # conversely, if not set, system files will be used as the source of truth
      if [[ $(yq -r '.config.configure.dotfiles.stowMode' "$CONFIG") == "override" ]] \
        && [[ -n $(git status --porcelain --untracked-files=no "$DOTFILES/$pkg/") ]]; then
        _info_msg "Overriding system original dotfiles with ${tides_txt}' dotfiles"
        # NOTE: commit any new changes made to dotfiles as they will be reset
        # if there are any changes detected.
        # TODO: explore a cleaner option than git restore
        git restore "$DOTFILES/$pkg/"
      fi
    done
  fi

  # generate GPG key
  if [[ $(yq '.config.configure.apps.gpg.genKey' "$CONFIG") == true ]]; then
    _info_msg "Generating GPG key"
    gpg --batch --full-gen-key <<EOF
%echo Generating a full key
Key-Type: RSA
Key-Length: 4096
Expire-Date: 0
Name-Real: $(yq '.gpg.name' "$SECRETS")
Name-Email: $(yq '.gpg.email' "$SECRETS")
Name-Comment: $(yq '.gpg.comment' "$SECRETS")
Passphrase: $(yq '.gpg.passphrase' "$SECRETS")
%commit
EOF

    if $EDIT; then
      _info_msg "Disabling gpg.genKey"
      yq -i '.config.configure.apps.gpg.genKey = false' "$CONFIG"
    fi
  fi

  # setup git user field in gitconfig via ~/.gitconfig.local
  if [[ $(yq '.config.configure.apps.git.userInfo' "$CONFIG") == true ]]; then
    _info_msg "Setting up \`.gitconfig.local\`"
    tee ~/.gitconfig.local <<EOF >/dev/null
[user]
    name = $(yq '.gitconfig.name' "$SECRETS")
    email = $(yq '.gitconfig.email' "$SECRETS")
EOF
    # add signingkey if field exists
    if [[ -n $(yq '.gitconfig.signingkey' "$SECRETS") ]]; then
      _info_msg "Adding signing key"
      # TODO: remove signingkey field if alr exists prior to append operation
      tee -a ~/.gitconfig.local <<EOF >/dev/null
    signingkey = $(yq '.gitconfig.signingkey' "$SECRETS")
EOF
    fi
  fi

  # setup Alacritty
  if [[ $(yq '.config.configure.apps.alacritty' "$CONFIG") == true ]] \
    && command -v alacritty &>/dev/null; then
    # add desktop icon
    if [[ ! -f /usr/share/pixmaps/Alacritty.svg ]]; then
      _info_msg "Adding Alacritty icon"
      sudo curl -fsLS --create-dirs -o /usr/share/pixmaps/Alacritty.svg \
        https://github.com/alacritty/alacritty/raw/master/extra/logo/alacritty-term.svg
    fi

    # add desktop entry
    if [[ ! -f /usr/share/applications/Alacritty.desktop ]]; then
      _info_msg "Adding desktop entry"
      sudo curl -fsLS --create-dirs -o /usr/share/applications/Alacritty.desktop \
        https://github.com/alacritty/alacritty/raw/master/extra/linux/Alacritty.desktop
      sudo update-desktop-database
    fi
  fi

  # setup docker
  if [[ $(yq '.config.configure.apps.docker' "$CONFIG") == true ]] \
    && command -v docker &>/dev/null; then
    _info_msg "Setting up docker"
    # https://docs.docker.com/engine/install/linux-postinstall/

    # manage docker as non-root user
    if ! id --name --groups "$USER" | grep docker &>/dev/null; then
      _info_msg "Adding user to docker group to allow user to execute docker commands"
      # create docker group
      sudo groupadd -f docker
      # add user to docker group
      sudo usermod -aG docker "$USER"
      # change group ID to docker to activate change in current shell
      newgrp docker
    fi

    # configure docker to start on boot (& right now) with systemd
    _info_msg "Configuring docker to start on boot"
    if ! systemctl -q is-active docker.service; then
      sudo systemctl enable --now docker.service
    fi
    if ! systemctl -q is-active containerd.service; then
      sudo systemctl enable --now containerd.service
    fi

    # use local logging driver to prevent disk-exhaustion
    # local logging driver performs log-rotation & compresses log files by
    # default.
    # https://docs.docker.com/config/containers/logging/configure/
    # https://docs.docker.com/config/containers/logging/local/
    if [[ "$(yq -r '.log-driver' /etc/docker/daemon.json)" != "local" ]]; then
      _info_msg "Using local logging driver to prevent disk-exhaustion"
      yq -p=j -n -o=j \
        '{"log-driver":"local","log-opts":{"max-size":"10m"}}' \
        | sudo tee /etc/docker/daemon.json >/dev/null
    fi
  fi

  # launches ulauncher
  if [[ $(yq '.config.configure.apps.ulauncher' "$CONFIG") == true ]] \
    && command -v ulauncher &>/dev/null; then
    if [[ ! -f "$HOME/.config/autostart/ulauncher.desktop" ]]; then
      _info_msg "Adding ulauncher to startup"
      cat <<EOF >"$HOME/.config/autostart/ulauncher.desktop"
[Desktop Entry]
Name=Ulauncher
Comment=Application launcher for Linux
GenericName=Launcher
Categories=GNOME;GTK;Utility;
TryExec=/usr/bin/ulauncher
Exec=env GDK_BACKEND=x11 /usr/bin/ulauncher --hide-window
Icon=ulauncher
Terminal=false
Type=Application
EOF
    else
      _info_msg "ulauncher already in startup apps"
    fi
  fi

  # setup virtualbox
  if [[ $(yq '.config.configure.apps.virtualbox' "$CONFIG") == true ]] \
    && command -v virtualbox &>/dev/null; then
    # to allow virtualbox to access USB devices, add $USER to vboxusers group
    # https://www.virtualbox.org/manual/ch02.html
    if ! id --name --groups "$USER" | grep vboxusers &>/dev/null; then
      _info_msg "Adding user to vboxusers group to allow user to execute virtualbox commands"
      # create vboxusers group
      sudo groupadd -f vboxusers
      # add user to vboxusers group
      sudo usermod -aG vboxusers "$USER"
      # change group ID to vboxusers to activate change in current shell
      newgrp vboxusers
    fi
  fi

  # install vscodium extensions
  if [[ $(yq '.config.configure.apps.vscodium.extensions | tag' "$CONFIG") == "!enabled" ]]; then
    _info_msg "Installing vscodium extensions"
    local extensions
    mapfile -t extensions < <(
      yq -r '.config.configure.apps.vscodium.extensions[]' "$CONFIG"
    )
    for ext in "${extensions[@]}"; do
      # install vscodium extensions
      # shellcheck disable=SC2086
      codium --install-extension $ext
    done
  fi

  # optimisations
  if [[ $(yq ".config.configure.optimisations" "$CONFIG") == "!enabled" ]]; then
    _info_msg "Configuring optimisations"

    if [[ $(yq ".config.configure.optimisations.auto-cpufreq" "$CONFIG") == true ]]; then
      _info_msg "Configuring auto-cpufreq"
      if ! command -v auto-cpufreq &>/dev/null; then
        _info_msg "Installing auto-cpufreq"
        git clone https://github.com/AdnanHodzic/auto-cpufreq.git
        cd auto-cpufreq && sudo ./auto-cpufreq-installer
        cd ..
        rm -rf auto-cpufreq
      fi
      if systemctl is-active --quiet auto-cpufreq; then
        _info_msg "auto-cpufreq daemon is already running"
      else
        sudo auto-cpufreq --install
      fi
    fi
  fi

  # desktop-environment specific configurations
  if [[ $(yq ".config.configure.DEConf | tag" "$CONFIG") == "!enabled" ]]; then
    _info_msg "Configuring desktop environment"

    # cinnamon settings
    if [[ $DESKTOP_ENVIRONMENT == "cinnamon" ]]; then
      if [[ $(yq ".config.configure.DEConf.cinnamon.defaultTerm | tag" "$CONFIG") == "!enabled" ]]; then
        local term=$(yq ".config.configure.DEConf.cinnamon.defaultTerm" "$CONFIG")
        _info_msg "Setting default terminal to $term"
        gsettings set org.cinnamon.desktop.default-applications.terminal exec "$term"
        gsettings set org.cinnamon.desktop.default-applications.terminal exec-arg ''
      fi

      # install & autostart plank dock
      if [[ $(yq ".config.configure.DEConf.cinnamon.plankDock" "$CONFIG") == true ]]; then
        if ! command -v plank &>/dev/null; then
          _info_msg "Installing plank"
          sudo apt-get update -qq && sudo apt-get install -qq plank
        fi
        if [[ ! -f "$HOME/.config/autostart/plank.desktop" ]]; then
          _info_msg "Adding plank to startup"
          # sleep for 2s to let apps load before adding to plank
          cat <<EOF >"$HOME/.config/autostart/plank.desktop"
[Desktop Entry]
Name=Plank
GenericName=Dock
Comment=Stupidly simple.
Categories=Utility;
Type=Application
Exec=bash -c "sleep 2 && plank"
Icon=plank
Terminal=false
NoDisplay=false
EOF
        else
          _info_msg "Plank already added to startup"
        fi
      fi

      # convert cinnamon panel to MacOS-like menu bar
      if [[ $(yq ".config.configure.DEConf.cinnamon.panelToMenuBar" "$CONFIG") == true ]]; then
        _info_msg "Converting panel to menu bar"
        # panel applets in order
        # https://support.apple.com/en-al/guide/mac-help/mchlp1446
        # https://support.apple.com/en-kw/guide/mac-help/mchlad96d366
        gsettings set org.cinnamon enabled-applets "[ \
          'panel1:left:0:menu@cinnamon.org:1', \
          'panel1:right:1:xapp-status@cinnamon.org:2', \
          'panel1:right:2:notifications@cinnamon.org:3', \
          'panel1:right:3:printers@cinnamon.org:4', \
          'panel1:right:4:removable-drives@cinnamon.org:5', \
          'panel1:right:5:keyboard@cinnamon.org:6', \
          'panel1:right:6:power@cinnamon.org:7', \
          'panel1:right:7:sound@cinnamon.org:8', \
          'panel1:right:8:network@cinnamon.org:9', \
          'panel1:right:9:calendar@cinnamon.org:10' \
        ]"
        # panel icon sizes
        gsettings set org.cinnamon panel-zone-symbolic-icon-sizes '[{"left": 25, "center": 25, "right": 20, "panelId": 1}]'
        # shift panel position to top
        gsettings set org.cinnamon panels-enabled "['1:0:top']"
        # smaller panel height
        gsettings set org.cinnamon panels-height "['1:25']"
      fi
    fi

    # gnome settings
    if [[ "$DESKTOP_ENVIRONMENT" == "gnome" ]]; then
      # install gnome-tweaks & gnome-shell-extensions
      if [[ $(yq ".config.configure.DEConf.gnome.tweaksAndExtensions" "$CONFIG") == true ]] \
        && { ! command -v gnome-tweaks || ! command -v gnome-extensions; }; then
        _info_msg "Installing gnome-tweaks and/or gnome-shell-extensions"
        sudo apt-get update -qq && sudo apt-get install -qq gnome-tweaks gnome-shell-extensions
      elif [[ $(yq ".config.configure.DEConf.gnome.tweaksAndExtensions" "$CONFIG") == true ]]; then
        _info_msg "gnome-tweaks & gnome-shell-extensions are already installed"
      fi

      if [[ $(yq ".config.configure.DEConf.gnome.defaultTerm | tag" "$CONFIG") == "!enabled" ]]; then
        local term=$(yq ".config.configure.DEConf.gnome.defaultTerm" "$CONFIG")
        _info_msg "Setting default terminal to $term"
        gsettings set org.gnome.desktop.default-applications.terminal exec "$term"
        gsettings set org.gnome.desktop.default-applications.terminal exec-arg ''
      fi

      # make Dash to Dock mimic MacOS dock behaviour
      if [[ $(yq ".config.configure.DEConf.gnome.MacOSDock" "$CONFIG") == true ]]; then
        _info_msg "Making Dash to Dock mimic MacOS dock behaviour"
        gsettings set org.gnome.shell.extensions.dash-to-dock dash-max-icon-size 32
        gsettings set org.gnome.shell.extensions.dash-to-dock dock-position 'BOTTOM'
        # disable panel mode
        gsettings set org.gnome.shell.extensions.dash-to-dock extend-height false
        # allow dock to be hidden
        gsettings set org.gnome.shell.extensions.dash-to-dock dock-fixed false
        # hide dock when focused application overlaps dock
        gsettings set org.gnome.shell.extensions.dash-to-dock intellihide true
        gsettings set org.gnome.shell.extensions.dash-to-dock intellihide-mode 'FOCUS_APPLICATION_WINDOWS'
        # show dock on mouse/cursor hover
        gsettings set org.gnome.shell.extensions.dash-to-dock autohide true
        gsettings set org.gnome.shell.extensions.dash-to-dock require-pressure-to-show false
      fi
    fi
  fi

  _success_msg "Finished ${tides_txt} configuration"
}

# ----- MAIN -----

main() {
  # PRINT FUNCTIONS
  _colours true

  # install curl if not installed
  if ! command -v curl &>/dev/null; then
    _info_msg "Installing curl"
    sudo apt-get install -qq curl # NOTE: do not update to save time
  fi

  # download & install yq if not installed
  if ! command -v yq &>/dev/null; then
    _info_msg "Installing yq"
    sudo curl -sSL -o /usr/bin/yq \
      https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
    sudo chmod +x /usr/bin/yq
  fi

  [[ $# -gt 0 ]] || {
    _usage
    _error_msg "No argument(s)"
  }

  while [[ $# -gt 0 ]]; do
    case $1 in
      -h | --help | h | help)
        _usage
        exit 0
        ;;
      # OPTIONS
      --no-colour) _colours false ;;
      --list-configs) list_configs ;;
      -c | --config)
        set_config "$2"
        shift
        ;;
      --secrets-file)
        set_secrets_file "$2"
        shift
        ;;
      -V | --version) get_version ;;
      # COMMANDS
      check) check ;;
      install) install ;;
      update) update ;;
      configure) configure ;;
      *)
        _usage
        _error_msg "Invalid argument(s)"
        ;;
    esac
    shift
  done
}

main "$@"
