#!/bin/bash

set -euo pipefail

# constants
readonly DOTFILES="dotfiles"
CONFIG="$(dirname "$0")/configs/default.yaml"
CONFIG_DIR="$(dirname "$0")/configs"
SECRETS="$(dirname "$0")/secrets.yaml"
# set in _set_constants()
DISTRO=
UPSTREAM_DISTRO=ubuntu
DESKTOP_ENVIRONMENT=

# ----- PRINT FUNCTIONS -----

# Set text colours if supported.
# Arguments:
#   colours enabled, a boolean
colours() {
  if [[ "$(tput colors)" -ge 8 ]] && [[ $1 == true ]]; then
    NC="$(tput sgr0)" # text reset (select graphic representation default)
    BOLD="$(tput bold)"
    RED="$(tput setaf 1)"            # red
    GREEN="$(tput setaf 2)"          # green
    YELLOW="$(tput setaf 3)"         # yellow
    BLUE="$(tput setaf 4)"           # blue
    MAGENTA="$(tput setaf 5)"        # magenta
    CYAN="$(tput setaf 6)"           # cyan
    B_RED="$(tput bold setaf 1)"     # bold red
    B_GREEN="$(tput bold setaf 2)"   # bold green
    B_YELLOW="$(tput bold setaf 3)"  # bold yellow
    B_BLUE="$(tput bold setaf 4)"    # bold blue
    B_MAGENTA="$(tput bold setaf 5)" # bold magenta
    B_CYAN="$(tput bold setaf 6)"    # bold cyan
    tides_txt="${B_RED}t${B_YELLOW}i${B_GREEN}d${B_BLUE}e${B_MAGENTA}s${NC}"
    TIDES_TXT="${B_RED}T${B_YELLOW}I${B_GREEN}D${B_BLUE}E${B_MAGENTA}S${NC}"
  else
    # don't set colours if argument is false (or not given). use `colours false` for readability
    NC=
    BOLD=
    RED=
    GREEN=
    YELLOW=
    BLUE=
    MAGENTA=
    CYAN=
    B_RED=
    B_GREEN=
    B_YELLOW=
    B_BLUE=
    B_MAGENTA=
    B_CYAN=
    tides_txt="tides"
    TIDES_TXT="TIDES"
  fi
}

_info_msg() { echo "${B_BLUE}Info:${NC} $1"; }

_success_msg() { echo "${B_GREEN}Success:${NC} $1"; }

_warning_msg() { echo "${B_YELLOW}Warning:${NC} $1"; }

_error_msg() {
  echo "${B_RED}Error:${NC} $1"
  exit 1
}

_usage() {
  cat <<EOF
${TIDES_TXT} (${B_RED}T${NC}he ${B_YELLOW}I${NC}dempotent ${B_GREEN}D${NC}ev ${B_BLUE}E${NC}nvironment ${B_MAGENTA}S${NC}etup) is an automated ${BOLD}post-install${NC}, ${BOLD}update${NC}, & ${BOLD}config (dotfile) manager${NC} for Linux

${YELLOW}Usage:${NC} ${tides_txt} ${CYAN}[Options]${NC} ${CYAN}[Command]${NC}

${YELLOW}Options:${NC}
  ${GREEN}-n, --no-colour       ${NC} Do not output any colour. Useful when redirecting output to a logfile
                         directory
  ${GREEN}-c, --config <CONFIG> ${NC} Set a config file that exists in \$CONFIG_DIR (default: ${BLUE}<tides_path>/configs/${NC})
  ${GREEN}-S, --secrets <SECRET>${NC} Set a secrets file. Add to ${BLUE}.gitignore${NC} if secrets file is in ${tides_txt} directory
  ${GREEN}    --list-configs    ${NC} List all available configs in \$CONFIG_DIR (default: ${BLUE}<tides_path>/configs/${NC})
                         directory
  ${GREEN}-h, --help            ${NC} Print help information
  ${GREEN}-V, --version         ${NC} Print version information

${YELLOW}Commands:${NC}

  ${GREEN}   check    ${NC} Purges bloat (default) & installs dependencies. Installs Python (via pyenv), Cargo
               (via rustup), appimaged, & fonts (Geist & Nerdfonts)
  ${GREEN}i, install  ${NC} Installs all apt (& alternative sources), flatpak, cargo, binary (AppImage) 
               packages, & coding languages (node & golang)
  ${GREEN}u, update   ${NC} Updates & upgrades apt, flatpak, cargo packages. Updates other packages & cleans
               system (see ${BLUE}configs/default.yaml${NC} for details)
  ${GREEN}c, configure${NC} Configures apps installed, restore / backup dotfiles via Stow (dotfile manager), 
               customise desktop environment (Cinnamon / GNOME), & performs other system configs
  ${GREEN}h, help     ${NC} Print help information

${YELLOW}Configuration:${NC}
  Customise the actions each command by modifying the ${BLUE}configs/default.yaml${NC} file.
  The full config schema of ${tides_txt} is available at ${BLUE}README.md${NC}.
  Preset configs are available in ${BLUE}<tides_path>/configs/${NC} directory. Add new configs in \$CONFIG_DIR
   (default: ${BLUE}<tides_path>/configs/${NC}) or list them with ${tides_txt} ${CYAN}--list-configs${NC}

${YELLOW}Example:${NC}
  ${tides_txt} ${CYAN}--config${NC} virtual_machine ${CYAN}configure${NC}

${YELLOW}Project Homepage:${NC} ${MAGENTA}https://github.com/adoreblvnk/tides${NC}

EOF
}

# ----- OPTIONS -----

# Use config specified in config directory.
# Arguments:
#   config that exists in $CONFIG_DIR
set_config() {
  CONFIG="${CONFIG_DIR}/$1.yaml"
  if [[ ! -f $CONFIG ]]; then
    _error_msg "Config selected \"$1\" does not exist"
  fi
}

# Use secrets file specified by user.
# Arguments:
#   secrets file as a path
set_secrets_file() {
  SECRETS="$(realpath "$1")"
  if [[ ! -f $SECRETS ]]; then
    _error_msg "Secrets file selected \"$1\" does not exist"
  fi
}

list_configs() {
  local configs
  # find all preset files, then filter out the parent dirs & file suffixes
  mapfile -t configs < <(
    find "$CONFIG_DIR" -type f | awk -F '[/.]' '{print $--NF}'
  )
  echo "${YELLOW}Available configs:${NC}"
  for config in "${configs[@]}"; do echo "  ${GREEN}$config${NC}"; done
}

get_version() {
  echo "${tides_txt} $(yq '.version' "$CONFIG")"
  exit
}

# ----- SET CONSTANTS -----

# Set complex constants that require commands to be set.
# Globals:
#   DISTRO
#   UPSTREAM_DISTRO: parent distro (eg Ubuntu is the upstream of Mint)
#   DESKTOP_ENVIRONMENT
#   VERSION_CODENAME: only if $UBUNTU_CODENAME exists
_set_constants() {
  # get distro & set $DISTRO
  . /etc/os-release # contains operating system identification data
  DISTRO="$(yq '.metadata.distro' "$CONFIG")"
  if [[ $DISTRO == "auto" ]]; then
    DISTRO="$ID" # TODO: create var to store upstream distro?
    local distro_auto=" (auto)"
  fi
  case "$DISTRO" in
    # https://github.com/which-distro/os-release
    ubuntu | linuxmint | pop | zorin | Deepin) ;;
    debian | kali | tails) UPSTREAM_DISTRO=debian ;;
    *) _error_msg "Unsupported distro detected or in config" ;;
  esac

  # get desktop environment & set $DESKTOP_ENVIRONMENT
  DESKTOP_ENVIRONMENT="$(yq '.metadata.desktopEnvironment' "$CONFIG")"
  # detect DE modified from https://cgit.freedesktop.org/xdg/xdg-utils/tree/scripts/xdg-utils-common.in#n296
  if [[ $DESKTOP_ENVIRONMENT == "auto" ]]; then
    case "$XDG_CURRENT_DESKTOP" in
      Cinnamon | X-Cinnamon) DESKTOP_ENVIRONMENT=cinnamon ;;
      *GNOME*) DESKTOP_ENVIRONMENT=gnome ;;
    esac
    local de_auto=" (auto)"
  fi
  case $DESKTOP_ENVIRONMENT in
    cinnamon | gnome) ;;
    '') _error_msg "${CYAN}.metadata.desktopEnvironment${NC} not set in config" ;;
    *) _warning_msg "${tides_txt} ${CYAN}configure${NC} will ${RED}not${NC} configure this unsupported desktop environment" ;;
  esac

  # substitute nothing if auto unset
  _info_msg "Distro: ${DISTRO}${distro_auto:-}, Desktop Environment: ${DESKTOP_ENVIRONMENT}${de_auto:-}"

  if [[ -n ${UBUNTU_CODENAME:-} ]]; then
    _info_msg "Ubuntu-based distro detected. overwriting \$VERSION_CODENAME to $UBUNTU_CODENAME"
    # overwrite $VERSION_CODENAME for adding repos which use $VERSION_CODENAME in config. Modifying
    # this system variable has no major consequences anyways
    # shellcheck disable=SC2034
    VERSION_CODENAME=$UBUNTU_CODENAME
  fi
}

# ----- HELPERS -----

# Downloads / updates golang.
# Arguments:
#   go version. must be either "latest" or <major>.<minor>.<patch> form
_dl_golang() {
  if [ -z "${1-}" ]; then _error_msg "no value supplied to _dl_golang"; fi
  local latest_go=$1
  if [[ $1 == "latest" ]]; then
    latest_go="$(
      curl -sSL "https://go.dev/dl/?mode=json" | yq '.[0].version' | cut -c 3-
    )"
  fi
  # add go to PATH
  if [ -d /usr/local/go ]; then export PATH=$PATH:/usr/local/go/bin; fi
  if ! command -v go &>/dev/null \
    || [[ "$(go version | cut -d ' ' -f 3)" != "go$latest_go" ]]; then
    _info_msg "Downloading golang $latest_go"
    curl -sSL -o "/tmp/go.tar.gz" "https://go.dev/dl/go${latest_go}.linux-amd64.tar.gz"
    sudo rm -rf /usr/local/go && sudo tar -C /usr/local -xzf /tmp/go.tar.gz
    _warning_msg "Temporarily exporting go to PATH. Export to ~/.bashrc with ${tides_txt} ${BLUE}configure${NC}"
    export PATH=$PATH:/usr/local/go/bin
  fi
  _info_msg "Golang (go $(go version | cut -d ' ' -f 3 | cut -c 3-)) installed"
}

# Downloads / updates Node via nvm. Requires nvm to be installed.
# Arguments:
#   node version. format must either be "latest" | <major>[.<minor>[.<patch>]]
_dl_node() {
  if [ -z "${1-}" ]; then _error_msg "no value supplied to _dl_node"; fi
  if ! command -v nvm &>/dev/null; then
    if [[ ! -f "$HOME/.nvm/nvm.sh" ]]; then
      _info_msg "Installing nvm"
      # nvm install script auto adds to PATH if needed
      curl -ssLo- https://github.com/nvm-sh/nvm/raw/master/install.sh | bash
    fi
    . "$HOME/.nvm/nvm.sh" # source to activate nvm
  fi
  local node_ver="$1"
  # set node_ver to "--lts" if value is "latest"
  [[ $1 == "latest" ]] && node_ver="--lts"
  # get latest node ver specified from nvm. NOTE: potentially flaky, investigate stability
  latest_node_ver=$(nvm version-remote "$node_ver")
  if [[ "$(nvm current)" != "$latest_node_ver" ]]; then
    _info_msg "Installing node $latest_node_ver"
    nvm install "$node_ver"
  fi
  _info_msg "NVM (nvm $(nvm -v), node $(node -v), npm $(npm -v)) installed"
}

# ----- COMMANDS -----

check() {
  _info_msg "Starting ${tides_txt} check..."

  _set_constants

  # setup ubuntu: remove snaps, install ubuntu-restricted-extras, disable auto upgrades
  if [[ $(yq '.config.check.distroCfg.ubuntu' "$CONFIG") == true ]] \
    && [[ $DISTRO == "ubuntu" ]]; then
    if command -v snap &>/dev/null; then
      _info_msg "Removing snap packages"
      mapfile -t snap_pkgs < <(
        snap list | grep -Ev '^(Name|bare|core[0-9][0-9]|snapd\s)' \
          | awk '{print $1}'
      )
      for pkg in "${snap_pkgs[@]}"; do snap remove --purge "$pkg"; done
      snap remove --purge "$(snap list | grep -o '^core[0-9][0-9]')"
      snap remove --purge bare
      snap remove --purge snapd
    fi
    if systemctl -q is-active snapd; then
      _info_msg "Stop & disable snap services"
      sudo systemctl stop snapd
      sudo systemctl disable snapd
    fi
    if command -v snapd &>/dev/null; then
      _info_msg "Removing snapd package from apt"
      sudo apt-get remove --purge -qq snapd
    fi
    if [[ -d ~/snap || -d /snap || -d /var/snap || -d /var/lib/snapd ]]; then
      _info_msg "Removing snap package directories / leftover snap directories"
      sudo rm -rf ~/snap /snap /var/snap /var/lib/snapd
    fi
    if [[ ! -f /etc/apt/preferences.d/nosnap.pref ]]; then
      _info_msg "Creating nosnap.pref to prevent snap from being reinstalled"
      sudo tee /etc/apt/preferences.d/nosnap.pref <<EOF >/dev/null
Package: snapd
Pin: release a=*
Pin-Priority: -10
EOF
    fi

    if ! dpkg -s ubuntu-restricted-extras; then
      _info_msg "Installing ubuntu-restricted-extras"
      sudo apt-get update -qq && sudo apt-get install -qq ubuntu-restricted-extras
    fi

    # disabling auto upgrades
    cat <<EOF >/etc/apt/apt.conf.d/20auto-upgrades
APT::Periodic::Update-Package-Lists "0";
APT::Periodic::Unattended-Upgrade "0";
EOF
  fi

  # setup mint: install multimedia codecs
  if [[ $(yq '.config.check.distroCfg.linuxmint' "$CONFIG") == true ]] \
    && [[ $DISTRO == "linuxmint" ]]; then
    if ! dpkg -s mint-meta-codecs &>/dev/null; then
      _info_msg "Installing mint-meta-codecs"
      sudo apt-get update -qq && sudo apt-get install -qq mint-meta-codecs
    fi
  fi

  # setup debian: enable sudo for user, add contrib + non-free sources
  if [[ $(yq '.config.check.distroCfg.debian' "$CONFIG") == true ]] \
    && [[ $DISTRO == "debian" ]]; then
    if ! getent group sudo | grep -q "$(whoami)"; then
      _warning_msg "Adding $(whoami) to sudo group. Restart to use sudo"
      usermod -aG sudo "$(whoami)"
    fi

    cat <<EOF | sudo tee /etc/apt/sources.list >/dev/null
deb http://deb.debian.org/debian $VERSION_CODENAME main contrib non-free non-free-firmware
deb-src http://deb.debian.org/debian $VERSION_CODENAME main contrib non-free non-free-firmware

deb http://deb.debian.org/debian-security ${VERSION_CODENAME}-security main contrib non-free non-free-firmware
deb-src http://deb.debian.org/debian-security ${VERSION_CODENAME}-security main contrib non-free non-free-firmware

# $VERSION_CODENAME updates, to get updates before a point release is made;
# see https://www.debian.org/doc/manuals/debian-reference/ch02.en.html#_updates_and_backports
deb http://deb.debian.org/debian ${VERSION_CODENAME}-updates main contrib non-free non-free-firmware
deb-src http://deb.debian.org/debian ${VERSION_CODENAME}-updates main contrib non-free non-free-firmware
EOF
  fi

  if [[ $(yq '.config.check.purge | tag' "$CONFIG") == "!enabled" ]]; then
    local purge_pkgs # collect purge packages into array
    mapfile -t purge_pkgs < <(yq '.config.check.purge[]' "$CONFIG")
    for pkg in "${purge_pkgs[@]}"; do
      if dpkg-query -W "$pkg" &>/dev/null; then
        _info_msg "Purging $pkg"
        sudo apt-get remove --purge -qq "$pkg" >/dev/null
      fi
    done
    # disable purge after 1st run to prevent purging properly installed packages
    yq -i '.config.check.purge tag = "!disabled"' "$CONFIG"
  fi

  # install dependency packages
  if [[ $(yq '.config.check.deps | tag' "$CONFIG") == "!enabled" ]]; then
    local apt_pkgs
    mapfile -t apt_pkgs < <(yq '.config.check.deps[]' "$CONFIG")
    sudo apt-get update -qq
    for pkg in "${apt_pkgs[@]}"; do
      if ! dpkg -s "$pkg" &>/dev/null; then
        _info_msg "Installing dependency package $pkg"
        sudo apt-get install -qq "$pkg"
      fi
    done
  fi

  # installs pyenv, installs python according to version specified in $CONFIG
  if [[ $(yq '.config.check.python | tag' "$CONFIG") == "!enabled" ]]; then
    if ! command -v pyenv &>/dev/null; then
      _info_msg "Installing pyenv"
      if [[ ! -d ~/.pyenv ]]; then
        # NOTE: if pyenv dir exists but pyenv command fails, this means that pyenv isn't in PATH
        # install pyenv-installer https://github.com/pyenv/pyenv-installer &:
        #   - pyenv https://github.com/pyenv/pyenv
        #   - pyenv-doctor https://github.com/pyenv/pyenv-doctor
        #   - pyenv-update https://github.com/pyenv/pyenv-update
        #   - pyenv-virtualenv https://github.com/pyenv/pyenv-virtualenv
        curl https://pyenv.run | bash
      fi

      _warning_msg "Temporarily exporting pyenv to PATH. Export to ~/.bashrc with ${tides_txt} ${BLUE}configure${NC}"
      export PATH="$HOME/.pyenv/bin:$PATH"
      eval "$(pyenv init -)"
      eval "$(pyenv virtualenv-init -)"
    else
      if [[ $(yq '.config.check.python.pyenvUpdate' "$CONFIG") == true ]]; then
        pyenv update 2>/dev/null
      fi
      _info_msg "pyenv $(pyenv --version | cut -d ' ' -f 2) is already installed"
    fi

    # install latest python version if pyenv python version is not latest.
    if [[ $(yq '.config.check.python.version' "$CONFIG") == "latest" ]]; then
      local latest_py=$(pyenv latest -k 3)
    else
      local latest_py=$(pyenv latest -k "$(yq '.config.check.python.version' "$CONFIG")")
    fi
    if [[ $(pyenv version-name) != "$latest_py" ]]; then
      # only install if python version exists but is not set to global
      if ! pyenv versions | grep "$latest_py"; then
        _info_msg "Installing latest Python version $latest_py"
        pyenv install "$(yq '.config.check.python.version' "$CONFIG")"
      fi
      _info_msg "Setting global Python version to $latest_py"
      pyenv global "$(yq '.config.check.python.version' "$CONFIG")"
    else
      _info_msg "Python $(pyenv version-name) is already the latest version"
    fi

    if [[ $(yq '.config.check.python.pip' "$CONFIG") == true ]]; then
      local py_ver="python$(yq '.config.check.python.version' "$CONFIG")"
      $py_ver -m pip install --upgrade pip
      _info_msg "Pip version $($py_ver -m pip -V | cut -d ' ' -f 2) installed"
    fi
  fi

  if [[ $(yq '.config.check.rustupCheck' "$CONFIG") == true ]] \
    && ! command -v rustup &>/dev/null; then
    _info_msg "Installing Rustup toolchain (rustup, rustc, cargo)"
    curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y
    _warning_msg "Temporarily adding cargo to PATH. Add to ~/.bashrc with ${tides_txt} ${BLUE}configure${NC}"
    . "$HOME/.bashrc"
  elif [[ $(yq '.config.check.rustupCheck' "$CONFIG") == true ]]; then
    _info_msg "Rustup $(rustup -V 2>/dev/null | cut -d ' ' -f 2) toolchain already installed"
  fi

  # setup appimaged if appimaged service isn't running or appimage.cleanInstall is specified
  if [[ $(yq '.config.check.appimaged | tag' "$CONFIG") == "!enabled" ]]; then
    if ! systemctl --user -q is-active appimaged \
      || [[ $(yq '.config.check.appimaged.cleanInstall' "$CONFIG") == true ]]; then
      _info_msg "Installing appimaged"
      # https://github.com/probonopd/go-appimage/tree/master/src/appimaged#initial-setup

      # remove pre-existing similar tools
      systemctl --user stop appimaged.service || true
      sudo apt-get remove -qy appimagelauncher || true

      # clear cache
      rm -rf "$HOME/.local/share/applications/appimage*"
      [ -f ~/.config/systemd/user/default.target.wants/appimagelauncherd.service ] \
        && rm ~/.config/systemd/user/default.target.wants/appimagelauncherd.service

      # download appimaged
      mkdir -p "$HOME/Applications"
      # get continuous release via GitHub api
      curl -sSL -o "$HOME/Applications/appimaged.AppImage" \
        "$(curl -sSL https://api.github.com/repos/probonopd/go-appimage/releases/tags/continuous \
          | yq '.assets[].browser_download_url | select(. == "*appimaged*x86_64.AppImage")')"

      # launch
      chmod +x "$HOME/Applications/appimaged.AppImage"
      "$HOME/Applications/appimaged.AppImage"
    else
      _info_msg "Appimaged service already running"
    fi
    # install libfuse2t64 (named libfuse2 on older systems) for legacy AppImages
    # https://github.com/AppImage/AppImageKit/wiki/FUSE
    local fuse2_lib=$(apt-cache search --names-only "^libfuse2" | cut -d ' ' -f 1)
    if ! dpkg -s "$fuse2_lib" &>/dev/null; then
      _info_msg "Installing $fuse2_lib"
      sudo apt-get update -qq && sudo apt-get install -qq "$fuse2_lib"
    fi
  fi

  # install nerdfont
  if [[ $(yq '.config.check.nerdfont | tag' "$CONFIG") == "!enabled" ]]; then
    local font=$(yq '.config.check.nerdfont' "$CONFIG")
    if [[ -z $(fc-list :family="$font NF") ]]; then
      if [[ ! -d "/usr/share/fonts/$font" ]]; then
        _info_msg "Downloading $font"
        sudo mkdir -p "/usr/share/fonts/$font"
        curl -sSL \
          "https://github.com/ryanoasis/nerd-fonts/releases/latest/download/$font.tar.xz" \
          | sudo tar -xvJ -C "/usr/share/fonts/$font"
      fi
      _info_msg "Reloading fc-cache"
      fc-cache -f
    else
      _info_msg "$font already installed"
    fi
  fi
}

install() {
  _info_msg "Starting ${tides_txt} install"

  if [[ $(yq '.config.install.check' "$CONFIG") == true ]]; then
    check
  else
    _set_constants
  fi

  # install apt packages
  if [[ $(yq '.config.install.apt | tag' "$CONFIG") == "!enabled" ]]; then
    local apt_pkgs
    mapfile -t apt_pkgs < <(yq '.config.install.apt[]' "$CONFIG")
    sudo apt-get update -qq
    for pkg in "${apt_pkgs[@]}"; do
      if ! dpkg -s "$pkg" &>/dev/null; then
        _info_msg "Installing $pkg"
        sudo apt-get install -qq "$pkg"
      fi
    done
  fi

  # install from 3rd-party repos
  if [[ $(yq '.config.install.addRepos | tag' "$CONFIG") == "!enabled" ]]; then
    _info_msg "Installing apt packages from third party repositories"

    # setting up signing keys & repo entries for source (repo)
    for ((i = 0; i < $(yq '.config.install.addRepos | length' "$CONFIG"); i++)); do
      local pkg_map=$(yq ".config.install.addRepos[$i]" "$CONFIG")
      local source_name=$(yq '.sourceName' <<<"$pkg_map")
      local download_url="$(yq '.remoteGpgKey' <<<"$pkg_map")"
      # eval string if subshell / variable detected
      grep -Eq '\$(\(|\{).*(\)|\})' <<<"$download_url" \
        && download_url="$(eval echo "$(yq '.remoteGpgKey' <<<"$pkg_map")")"

      # download asc key from remote
      if [[ $(yq '.gpgKeyPath' <<<"$pkg_map") == *.asc ]]; then
        _info_msg "Downloading .asc key for $source_name"
        sudo curl -fsSL -o "$(yq '.gpgKeyPath' <<<"$pkg_map")" "$download_url"
      # if key is in gpg format, then dearmor after downloading the key
      elif [[ $(yq '.gpgKeyPath' <<<"$pkg_map") == *.gpg ]]; then
        _info_msg "Downloading & dearmoring .gpg key for $source_name"
        sudo curl -fsSL "$download_url" \
          | sudo gpg --dearmor --yes -o "$(yq '.gpgKeyPath' <<<"$pkg_map")"
      else
        _error_msg "Unsupported apt key format ($(yq '.gpgKeyPath' <<<"$pkg_map")) for $source_name source"
      fi

      # add repo entry into sources.list.d
      local source_file_path="/etc/apt/sources.list.d/$source_name.list"
      _info_msg "Adding repo entry for $source_name into sources.list.d"
      eval echo "$(yq '.repo' <<<"$pkg_map")" \
        | sudo tee "$source_file_path" >/dev/null

      # perform pinning if pinning entry exists
      if [[ $(yq '.pinning' <<<"$pkg_map") != false ]]; then
        _info_msg "Performing pinning to prioritise $source_name"
        # perform pinning to prioritise
        local pref_file="/etc/apt/preferences.d/$source_name"
        yq '.pinning' <<<"$pkg_map" \
          | sudo tee "$pref_file" >/dev/null
      fi
    done

    # install packages
    local apt_pkgs
    mapfile -t apt_pkgs < <(yq '.config.install.addRepos[].packages[]' "$CONFIG")
    sudo apt-get update -qq
    for pkg in "${apt_pkgs[@]}"; do
      if ! dpkg -s "$pkg" &>/dev/null; then
        _info_msg "Installing third party package $pkg"
        sudo apt-get install -qq "$pkg"
      fi
    done
  fi

  # install flatpaks if flatpak is installed
  if [[ $(yq '.config.install.flatpak | tag' "$CONFIG") == "!enabled" ]] \
    && command -v flatpak &>/dev/null; then
    _info_msg "Installing flatpak packages"
    if ! flatpak remotes | grep -iq "^flathub"; then
      _info_msg "Adding flathub repository"
      flatpak remote-add \
        --if-not-exists flathub https://dl.flathub.org/repo/flathub.flatpakrepo
    fi
    # shellcheck disable=SC2046
    flatpak install -y flathub $(yq '.config.install.flatpak[]' "$CONFIG")
  fi

  # install cargo packages if cargo is installed
  if [[ $(yq '.config.install.cargo | tag' "$CONFIG") == "!enabled" ]] \
    && command -v cargo &>/dev/null; then
    _info_msg "Installing cargo packages"
    local rust_pkgs
    mapfile -t rust_pkgs < <(yq '.config.install.cargo[]' "$CONFIG")
    for pkg in "${rust_pkgs[@]}"; do
      if ! cargo install --list | grep "$(cut -d ' ' -f 1 <<<"$pkg")" >/dev/null; then
        # shellcheck disable=SC2086
        cargo install $pkg
      fi
    done
  fi

  # install binary packages
  if [[ $(yq '.config.install.binaries | tag' "$CONFIG") == "!enabled" ]]; then
    _info_msg "Installing binary packages"
    mkdir -p "$HOME/Applications"
    for ((i = 0; i < "$(yq '.config.install.binaries | length' "$CONFIG")"; i++)); do
      local binary_map=$(yq ".config.install.binaries[$i]" "$CONFIG")
      local binary_name=$(yq '.name' <<<"$binary_map")
      # skip if binary / command (for .deb) exists
      if [[ -f "$HOME/Applications/$binary_name" ]] \
        || command -v "$(head -c '-5' <<<"$binary_name")" &>/dev/null; then
        _info_msg "$binary_name already exists"
        continue
      fi

      # downloading binary from url
      _info_msg "Downloading $binary_name"
      local download_url="$(yq '.url' <<<"$binary_map")"
      # eval string if subshell / variable detected
      grep -Eq '\$(\(|\{).*(\)|\})' <<<"$download_url" \
        && download_url="$(eval echo "$(yq '.url' <<<"$binary_map")")"
      curl -fsSL -o "$HOME/Applications/$binary_name" "$download_url"

      # install binary (AppImage / deb package)
      _info_msg "Installing $binary_name"
      if [[ $binary_name == *.AppImage ]]; then
        chmod +x "$HOME/Applications/$binary_name"
      elif [[ $binary_name == *.deb ]]; then
        sudo apt-get install -qq "$HOME/Applications/$binary_name"
        rm -f "$HOME/Applications/$binary_name"
      else
        _warning_msg "Unsupported package: $binary_name"
        _error_msg "${tides_txt} currently supports AppImage / deb packages only"
      fi
    done
  fi

  # install golang
  if [[ $(yq '.config.install.languages.goVersion | tag' "$CONFIG") == "!enabled" ]]; then
    _dl_golang "$(yq '.config.install.languages.goVersion' "$CONFIG")"
  fi

  # install nvm, node (& npm)
  if [[ $(yq '.config.install.languages.nodeVersion | tag' "$CONFIG") == "!enabled" ]]; then
    _dl_node "$(yq '.config.install.languages.nodeVersion' "$CONFIG")"
  fi

  _success_msg "Finished ${tides_txt} install. You may need to reload your shell with ${BLUE}. ~/.bashrc${NC} to use certain commands"
}

update() {
  _info_msg "Starting ${tides_txt} update"

  if [[ $(yq '.config.update.check' "$CONFIG") == true ]]; then
    check
  else
    _set_constants
  fi

  if [[ $(yq '.config.update.apt | tag' "$CONFIG") == "!enabled" ]]; then
    _info_msg "Updating & upgrading apt packages"
    sudo apt-get -qq update
    sudo apt-get -qy upgrade
    # aptFull upgrades the entire system, installing new packages if necessary, & removes old
    # archive files & unused packages with their config files
    if [[ $(yq '.config.update.apt.aptFull' "$CONFIG") == true ]]; then
      _info_msg "Performing a full upgrade & removing uneeded packages & apt cache"
      sudo apt-get -qy dist-upgrade
      sudo apt-get -qy autoclean
      sudo apt-get -qy --purge autoremove
    fi
  fi

  # update flatpak
  if [[ $(yq '.config.update.flatpak' "$CONFIG") == true ]] \
    && command -v flatpak &>/dev/null; then
    _info_msg "Updating flatpaks"
    flatpak update -y
  fi

  # update rustup & cargo
  if [[ $(yq '.config.update.cargo' "$CONFIG") == true ]] \
    && command -v rustup &>/dev/null \
    && command -v cargo &>/dev/null; then
    _info_msg "Updating rustup $(rustup -V 2>/dev/null | cut -d ' ' -f 2) & cargo $(cargo -V | cut -d ' ' -f 2) packages"
    rustup update 2>/dev/null
    # install cargo-update package if not installed
    cargo install --list | grep -q "^cargo-update" \
      || cargo install cargo-update
    cargo install-update -a
  fi

  # update yq
  if [[ $(yq '.config.update.other.yq' "$CONFIG") == true ]]; then
    local_yq_ver=$(yq -V | cut -d ' ' -f 4)
    # get latest yq version
    latest_yq_ver=$(
      curl -sSL https://api.github.com/repos/mikefarah/yq/releases/latest \
        | yq '.tag_name'
    )
    if [[ $local_yq_ver != "$latest_yq_ver" ]]; then
      _info_msg "Downloading & installing latest yq (version $latest_yq_ver)"
      sudo curl -sSL -o /usr/bin/yq \
        https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
      sudo chmod +x /usr/bin/yq
    else
      _info_msg "yq $local_yq_ver is already the latest version"
    fi
  fi

  # update golang
  if [[ $(yq '.config.update.other.go' "$CONFIG") == true ]] \
    && command -v go &>/dev/null; then
    _dl_golang latest
  fi

  # update node if exists
  if [[ $(yq '.config.update.other.node' "$CONFIG") == true ]] \
    && [[ -f "$HOME/.nvm/nvm.sh" ]]; then
    _dl_node latest
  fi

  # zellij delete all other sessions, including exited ones
  if [[ $(yq '.config.update.other.zellijClear' "$CONFIG") == true ]] \
    && command -v zellij &>/dev/null; then
    _info_msg "Deleting all other Zellij sessions"
    zellij delete-all-sessions -y
  fi

  _success_msg "Finished ${tides_txt} update"
}

configure() {
  _info_msg "Starting ${tides_txt} configuration"

  if [[ $(yq '.config.configure.check' "$CONFIG") == true ]]; then
    check
  else
    _set_constants
  fi

  # dotfile manager implementation via Stow
  if [[ $(yq '.config.configure.dotfiles | tag' "$CONFIG") == "!enabled" ]] \
    && command -v stow &>/dev/null; then
    _info_msg "Configuring dotfiles via Stow"
    local packages
    mapfile -t packages < <(
      yq -r '.config.configure.dotfiles.packages[]' "$CONFIG"
    )
    for pkg in "${packages[@]}"; do
      _info_msg "Stowing dotfiles for $pkg"
      # symlink between tides & actual dotfiles
      #   --no-folding stows individual files instead of directories
      #   --adopt replaces tides' dotfiles with original system ones
      #    this is needed as Stow throws an error if there are existing system dotfiles
      #    this results in tides' dotfiles being lost, but this is mitigated by setting
      #    .config.configure.stowMode to "override".
      stow --no-folding --adopt -v -d "dotfiles/" -t "$HOME" "$pkg"
      # override option overrides system files with tides' dotfiles pre-replacement
      # conversely, if not set, system files will be used as the source of truth
      if [[ $(yq -r '.config.configure.dotfiles.stowMode' "$CONFIG") == "override" ]] \
        && [[ -n $(git status --porcelain --untracked-files=no "$DOTFILES/$pkg/") ]]; then
        _info_msg "Overriding system original dotfiles with ${tides_txt}' dotfiles"
        # NOTE: commit any new changes made to dotfiles as they will be reset
        # if there are any changes detected.
        # TODO: explore a cleaner option than git restore
        git restore "$DOTFILES/$pkg/"
      fi
    done
  fi

  # setup git user field in gitconfig via ~/.gitconfig.local
  if [[ $(yq '.config.configure.apps.git.userInfo' "$CONFIG") == true ]] \
    && [[ -n $(yq '.gitconfig.name' "$SECRETS") ]] \
    && [[ -n $(yq '.gitconfig.email' "$SECRETS") ]]; then
    _info_msg "Adding name & email to ${BLUE}~/.gitconfig.local${NC}"
    tee ~/.gitconfig.local <<EOF >/dev/null
[user]
    name = $(yq '.gitconfig.name' "$SECRETS")
    email = $(yq '.gitconfig.email' "$SECRETS")
EOF
    # add signingkey if field exists
    if [[ -n $(yq '.gitconfig.signingkey' "$SECRETS") ]]; then
      _info_msg "Adding signing key"
      echo "    signingkey = $(yq '.gitconfig.signingkey' "$SECRETS")" \
        | tee -a ~/.gitconfig.local >/dev/null
    fi
  elif [[ $(yq '.config.configure.apps.git.userInfo' "$CONFIG") == true ]]; then
    _error_msg ".gitconfig.name or .gitconfig.email not set in $SECRETS"
  fi

  # setup Alacritty
  if [[ $(yq '.config.configure.apps.alacritty' "$CONFIG") == true ]] \
    && command -v alacritty &>/dev/null; then
    if [ ! -f ~/.bash_completion/alacritty ]; then
      _info_msg "Adding bash completion for Alacritty"
      curl -fsLS --create-dirs -o ~/.bash_completion/alacritty \
        https://github.com/alacritty/alacritty/raw/master/extra/completions/alacritty.bash
    fi

    # add desktop icon
    if [[ ! -f /usr/share/pixmaps/Alacritty.svg ]]; then
      _info_msg "Adding Alacritty icon"
      sudo curl -fsLS --create-dirs -o /usr/share/pixmaps/Alacritty.svg \
        https://github.com/alacritty/alacritty/raw/master/extra/logo/alacritty-term.svg
    fi

    # add desktop entry
    if [[ ! -f /usr/share/applications/Alacritty.desktop ]]; then
      _info_msg "Adding desktop entry"
      sudo curl -fsLS --create-dirs -o /usr/share/applications/Alacritty.desktop \
        https://github.com/alacritty/alacritty/raw/master/extra/linux/Alacritty.desktop
      sudo update-desktop-database
    fi
  fi

  # setup docker
  if [[ $(yq '.config.configure.apps.docker' "$CONFIG") == true ]] \
    && command -v docker &>/dev/null; then
    _info_msg "Setting up docker"
    # https://docs.docker.com/engine/install/linux-postinstall/

    # manage docker as non-root user
    if ! id --name --groups "$USER" | grep docker &>/dev/null; then
      _info_msg "Adding user to docker group to allow user to execute docker commands"
      # create docker group
      sudo groupadd -f docker
      # add user to docker group
      sudo usermod -aG docker "$USER"
      # change group ID to docker to activate change in current shell
      newgrp docker
    fi

    # configure docker to start on boot (& right now) with systemd
    _info_msg "Configuring docker to start on boot"
    if ! systemctl -q is-active docker.service; then
      sudo systemctl enable --now docker.service
    fi
    if ! systemctl -q is-active containerd.service; then
      sudo systemctl enable --now containerd.service
    fi

    # use local logging driver to prevent disk-exhaustion
    # local logging driver performs log-rotation & compresses log files by
    # default.
    # https://docs.docker.com/config/containers/logging/configure/
    # https://docs.docker.com/config/containers/logging/local/
    if [[ "$(yq -r '.log-driver' /etc/docker/daemon.json)" != "local" ]]; then
      _info_msg "Using local logging driver to prevent disk-exhaustion"
      yq -p=j -n -o=j \
        '{"log-driver":"local","log-opts":{"max-size":"10m"}}' \
        | sudo tee /etc/docker/daemon.json >/dev/null
    fi
  fi

  # launches ulauncher
  if [[ $(yq '.config.configure.apps.ulauncher' "$CONFIG") == true ]] \
    && command -v ulauncher &>/dev/null; then
    if [[ ! -f "$HOME/.config/autostart/ulauncher.desktop" ]]; then
      _info_msg "Adding ulauncher to startup"
      cat <<EOF >"$HOME/.config/autostart/ulauncher.desktop"
[Desktop Entry]
Name=Ulauncher
Comment=Application launcher for Linux
GenericName=Launcher
Categories=GNOME;GTK;Utility;
TryExec=/usr/bin/ulauncher
Exec=env GDK_BACKEND=x11 /usr/bin/ulauncher --hide-window
Icon=ulauncher
Terminal=false
Type=Application
EOF
    else
      _info_msg "ulauncher already in startup apps"
    fi
  fi

  # setup virtualbox
  if [[ $(yq '.config.configure.apps.virtualbox' "$CONFIG") == true ]] \
    && command -v virtualbox &>/dev/null; then
    # to allow virtualbox to access USB devices, add $USER to vboxusers group
    # https://www.virtualbox.org/manual/ch02.html
    if ! id --name --groups "$USER" | grep vboxusers &>/dev/null; then
      _info_msg "Adding user to vboxusers group to allow user to execute virtualbox commands"
      # create vboxusers group
      sudo groupadd -f vboxusers
      # add user to vboxusers group
      sudo usermod -aG vboxusers "$USER"
      # change group ID to vboxusers to activate change in current shell
      newgrp vboxusers
    fi
  fi

  # install vscode extensions
  if [[ $(yq '.config.configure.apps.vscode.extensions | tag' "$CONFIG") == "!enabled" ]] \
    && command -v code &>/dev/null; then
    _info_msg "Installing vscode extensions"
    local extensions
    mapfile -t extensions < <(
      yq -r '.config.configure.apps.vscode.extensions[]' "$CONFIG"
    )
    local installed_ext=$(code --list-extensions)
    for ext in "${extensions[@]}"; do
      if ! grep -iq "$ext" <<<"$installed_ext"; then
        # install vscode extensions
        code --install-extension "$ext"
      fi
    done
  fi

  # optimisations
  if [[ $(yq ".config.configure.optimisations" "$CONFIG") == "!enabled" ]]; then
    _info_msg "Configuring optimisations"

    if [[ $(yq ".config.configure.optimisations.auto-cpufreq" "$CONFIG") == true ]]; then
      _info_msg "Configuring auto-cpufreq"
      if ! command -v auto-cpufreq &>/dev/null; then
        _info_msg "Installing auto-cpufreq"
        git clone https://github.com/AdnanHodzic/auto-cpufreq.git
        cd auto-cpufreq && sudo ./auto-cpufreq-installer
        cd ..
        rm -rf auto-cpufreq
      fi
      if systemctl is-active --quiet auto-cpufreq; then
        _info_msg "auto-cpufreq daemon is already running"
      else
        sudo auto-cpufreq --install
      fi
    fi
  fi

  # desktop-environment specific configurations
  if [[ $(yq ".config.configure.DEConf | tag" "$CONFIG") == "!enabled" ]]; then
    _info_msg "Configuring desktop environment"

    # cinnamon settings
    if [[ $DESKTOP_ENVIRONMENT == "cinnamon" ]]; then
      if [[ $(yq ".config.configure.DEConf.cinnamon.defaultTerm | tag" "$CONFIG") == "!enabled" ]]; then
        local term=$(yq ".config.configure.DEConf.cinnamon.defaultTerm" "$CONFIG")
        _info_msg "Setting default terminal to $term"
        gsettings set org.cinnamon.desktop.default-applications.terminal exec "$term"
        gsettings set org.cinnamon.desktop.default-applications.terminal exec-arg ''
      fi

      # install & autostart plank dock
      if [[ $(yq ".config.configure.DEConf.cinnamon.plankDock" "$CONFIG") == true ]]; then
        if ! command -v plank &>/dev/null; then
          _info_msg "Installing plank"
          sudo apt-get update -qq && sudo apt-get install -qq plank
        fi

        _info_msg "Adding plank to startup"
        # sleep to let apps load before adding to plank
        cat <<EOF >"$HOME/.config/autostart/plank.desktop"
[Desktop Entry]
Name=Plank
GenericName=Dock
Comment=Stupidly simple.
Categories=Utility;
Type=Application
Exec=bash -c "sleep 5 && plank"
Icon=plank
Terminal=false
NoDisplay=false
EOF
      fi

      # convert cinnamon panel to MacOS-like menu bar
      if [[ $(yq ".config.configure.DEConf.cinnamon.panelToMenuBar" "$CONFIG") == true ]]; then
        _info_msg "Converting panel to menu bar"
        # panel applets in order
        # https://support.apple.com/en-al/guide/mac-help/mchlp1446
        # https://support.apple.com/en-kw/guide/mac-help/mchlad96d366
        gsettings set org.cinnamon enabled-applets "[ \
          'panel1:left:0:menu@cinnamon.org:1', \
          'panel1:right:1:xapp-status@cinnamon.org:2', \
          'panel1:right:2:notifications@cinnamon.org:3', \
          'panel1:right:3:printers@cinnamon.org:4', \
          'panel1:right:4:removable-drives@cinnamon.org:5', \
          'panel1:right:5:keyboard@cinnamon.org:6', \
          'panel1:right:6:power@cinnamon.org:7', \
          'panel1:right:7:sound@cinnamon.org:8', \
          'panel1:right:8:network@cinnamon.org:9', \
          'panel1:right:9:calendar@cinnamon.org:10' \
        ]"
        # panel icon sizes
        gsettings set org.cinnamon panel-zone-symbolic-icon-sizes '[{"left": 25, "center": 25, "right": 20, "panelId": 1}]'
        # shift panel position to top
        gsettings set org.cinnamon panels-enabled "['1:0:top']"
        # smaller panel height
        gsettings set org.cinnamon panels-height "['1:25']"
      fi

      if [[ $(yq ".config.configure.DEConf.cinnamon.flameshot" "$CONFIG") == true ]]; then
        _info_msg "Configuring flameshot shortcut to Print (PrtSc) key"
        dconf write /org/cinnamon/desktop/keybindings/custom-keybindings/custom0/name "'flameshot'"
        dconf write /org/cinnamon/desktop/keybindings/custom-keybindings/custom0/command "'/usr/bin/flameshot gui'"
        dconf write /org/cinnamon/desktop/keybindings/custom-keybindings/custom0/binding "['Print']"
      fi

      # install gTile tiling assistant
      if [[ $(yq ".config.configure.DEConf.cinnamon.gTile | tag" "$CONFIG") == "!enabled" ]]; then
        if [[ ! -d "$HOME/.local/share/cinnamon/extensions/gTile@shuairan" ]]; then
          _info_msg "Downloading gTile extension"
          curl -sSL -o /tmp/gTile@shuairan.zip \
            https://cinnamon-spices.linuxmint.com/files/extensions/gTile@shuairan.zip
          unzip /tmp/gTile@shuairan.zip \
            -d "$HOME/.local/share/cinnamon/extensions" >/dev/null
        fi
        if ! gsettings get org.cinnamon enabled-extensions | grep -q "gTile"; then
          _warning_msg "Enabling gTile will disable other extensions"
          gsettings set org.cinnamon enabled-extensions "['gTile@shuairan']"
        else
          _info_msg "gTile already enabled"
        fi

        # opinionated tiling layout
        if [[ $(yq ".config.configure.DEConf.cinnamon.gTile.tilingLayout" "$CONFIG") == true ]]; then
          _info_msg "Configuring opinionated tiling layout for gTile"
          mkdir -p "$HOME/.local/share/cinnamon/extensions/gTile@shuairan"
          cp "$(dirname "$0")/extras/gTile@shuairan.json" \
            "$HOME/.local/share/cinnamon/extensions/gTile@shuairan/gTile@shuairan.json"
        fi
      fi
    fi

    # gnome settings
    if [[ "$DESKTOP_ENVIRONMENT" == "gnome" ]]; then
      # install gnome-tweaks & gnome-shell-extensions
      if [[ $(yq ".config.configure.DEConf.gnome.tweaksAndExtensions" "$CONFIG") == true ]] \
        && { ! command -v gnome-tweaks || ! command -v gnome-extensions; }; then
        _info_msg "Installing gnome-tweaks and/or gnome-shell-extensions"
        sudo apt-get update -qq && sudo apt-get install -qq gnome-tweaks gnome-shell-extensions
      elif [[ $(yq ".config.configure.DEConf.gnome.tweaksAndExtensions" "$CONFIG") == true ]]; then
        _info_msg "gnome-tweaks & gnome-shell-extensions are already installed"
      fi

      if [[ $(yq ".config.configure.DEConf.gnome.defaultTerm | tag" "$CONFIG") == "!enabled" ]]; then
        local term=$(yq ".config.configure.DEConf.gnome.defaultTerm" "$CONFIG")
        _info_msg "Setting default terminal to $term"
        gsettings set org.gnome.desktop.default-applications.terminal exec "$term"
        gsettings set org.gnome.desktop.default-applications.terminal exec-arg ''
      fi

      # make Dash to Dock mimic MacOS dock behaviour
      if [[ $(yq ".config.configure.DEConf.gnome.MacOSDock" "$CONFIG") == true ]]; then
        _info_msg "Making Dash to Dock mimic MacOS dock behaviour"
        # minimize on click when application is opened
        gsettings set org.gnome.shell.extensions.dash-to-dock click-action 'minimize-or-previews'
        gsettings set org.gnome.shell.extensions.dash-to-dock dash-max-icon-size 32
        gsettings set org.gnome.shell.extensions.dash-to-dock dock-position 'BOTTOM'
        # disable panel mode
        gsettings set org.gnome.shell.extensions.dash-to-dock extend-height false
        # allow dock to be hidden
        gsettings set org.gnome.shell.extensions.dash-to-dock dock-fixed false
        # hide dock when focused application overlaps dock
        gsettings set org.gnome.shell.extensions.dash-to-dock intellihide true
        gsettings set org.gnome.shell.extensions.dash-to-dock intellihide-mode 'FOCUS_APPLICATION_WINDOWS'
        # show dock on mouse/cursor hover
        gsettings set org.gnome.shell.extensions.dash-to-dock autohide true
        gsettings set org.gnome.shell.extensions.dash-to-dock require-pressure-to-show false
      fi

      if [[ $(yq ".config.configure.DEConf.gnome.flameshot" "$CONFIG") == true ]]; then
        _info_msg "Configuring flameshot shortcut to Print (PrtSc) key"
        gsettings set org.gnome.shell.keybindings show-screenshot-ui '[]'
        dconf write /org/gnome/settings-daemon/plugins/media-keys/custom-keybindings \
          "['/org/gnome/settings-daemon/plugins/media-keys/custom-keybindings/custom0/']"
        dconf write /org/gnome/settings-daemon/plugins/media-keys/custom-keybindings/custom0/name "'flameshot'"
        dconf write /org/gnome/settings-daemon/plugins/media-keys/custom-keybindings/custom0/command "'/usr/bin/flameshot gui'"
        dconf write /org/gnome/settings-daemon/plugins/media-keys/custom-keybindings/custom0/binding "'Print'"
      fi
    fi
  fi

  _success_msg "Finished ${tides_txt} configuration. You may need to run ${BLUE}. ~/.bashrc${NC} if commands aren't recognised"
}

# ----- MAIN -----

main() {
  # PRINT FUNCTIONS
  colours true

  # install curl if not installed
  if ! command -v curl &>/dev/null; then
    _info_msg "Installing curl"
    sudo apt-get install -qq curl # NOTE: do not update to save time
  fi

  # download & install yq if not installed
  if ! command -v yq &>/dev/null; then
    _info_msg "Installing yq"
    sudo curl -sSL -o /usr/bin/yq \
      https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
    sudo chmod +x /usr/bin/yq
  fi

  [[ $# -gt 0 ]] || {
    _usage
    _error_msg "No argument(s)"
  }

  while [[ $# -gt 0 ]]; do
    case $1 in
      -h | --help | h | help)
        _usage
        exit 0
        ;;
      # OPTIONS
      -n | --no-colour) colours false ;;
      -c | --config)
        set_config "$2"
        shift
        ;;
      -S | --secrets)
        set_secrets_file "$2"
        shift
        ;;
      --list-configs) list_configs ;;
      -V | --version) get_version ;;
      # COMMANDS
      check) check ;;
      install) install ;;
      update) update ;;
      configure) configure ;;
      *)
        _usage
        _error_msg "Invalid argument(s)"
        ;;
    esac
    shift
  done
}

main "$@"
