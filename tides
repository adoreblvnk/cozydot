#!/bin/bash

set -euo pipefail

# constants
readonly DOTFILES="dotfiles"
CONFIG="$(dirname "$0")/configs/default.yaml"
SECRETS="$(dirname "$0")/secrets.yaml"
CONFIG_DIR="$(dirname "$0")/configs"
# set in _set_constants
DISTRO=
DESKTOP_ENVIRONMENT=

# ----- PRINT FUNCTIONS -----

# Set text colours if supported.
# Arguments:
#   colours enabled, a boolean
_colours() {
  if [[ "$(tput colors)" -ge 8 ]] \
    && [[ $1 == true ]]; then
    NC="$(tput sgr0)" # text reset (select graphic representation default)
    BOLD="$(tput bold)"
    RED="$(tput setaf 1)"            # red
    GREEN="$(tput setaf 2)"          # green
    YELLOW="$(tput setaf 3)"         # yellow
    BLUE="$(tput setaf 4)"           # blue
    MAGENTA="$(tput setaf 5)"        # magenta
    CYAN="$(tput setaf 6)"           # cyan
    B_RED="$(tput bold setaf 1)"     # bold red
    B_GREEN="$(tput bold setaf 2)"   # bold green
    B_YELLOW="$(tput bold setaf 3)"  # bold yellow
    B_BLUE="$(tput bold setaf 4)"    # bold blue
    B_MAGENTA="$(tput bold setaf 5)" # bold magenta
    B_CYAN="$(tput bold setaf 6)"    # bold cyan
    tides_txt="${B_RED}t${B_YELLOW}i${B_GREEN}d${B_BLUE}e${B_MAGENTA}s${NC}"
    TIDES_TXT="${B_RED}T${B_YELLOW}I${B_GREEN}D${B_BLUE}E${B_MAGENTA}S${NC}"
  # don't set colours if argument is false (or not given). use `_colours false` for readability
  else
    NC=
    BOLD=
    RED=
    GREEN=
    YELLOW=
    BLUE=
    MAGENTA=
    CYAN=
    B_RED=
    B_GREEN=
    B_YELLOW=
    B_BLUE=
    B_MAGENTA=
    B_CYAN=
    tides_txt="tides"
    TIDES_TXT="TIDES"
  fi
}

_info_msg() { echo "${B_BLUE}Info:${NC} $1"; }

_success_msg() { echo "${B_GREEN}Success:${NC} $1"; }

_warning_msg() { echo "${B_YELLOW}Warning:${NC} $1"; }

_error_msg() {
  echo "${B_RED}Error:${NC} $1"
  exit 1
}

_usage() {
  cat <<EOF
${TIDES_TXT} (${B_RED}T${NC}he ${B_YELLOW}I${NC}dempotent ${B_GREEN}D${NC}ev ${B_BLUE}E${NC}nvironment ${B_MAGENTA}S${NC}etup) is a ${BOLD}post-install${NC}, ${BOLD}update${NC}, ${BOLD}config${NC}, & ${BOLD}dotfile manager${NC} script for Linux systems

${YELLOW}Usage:${NC} ${tides_txt} ${CYAN}[Options]${NC} ${CYAN}[Command]${NC}

${YELLOW}Options:${NC}
  ${GREEN}    --no-colour${NC} Do not output any colour. Useful when redirecting output to a logfile
  ${GREEN}-c, --config ${NC}   Set a custom config yaml file [default: ${BLUE}<tides_path>/config.yaml${NC}]
  ${GREEN}-s, --secrets${NC}   Set a custom secrets yaml file [default: ${BLUE}<tides_path>/secrets.yaml${NC}]
  ${GREEN}-h, --help   ${NC}   Print help information

${YELLOW}Commands:${NC}
  ${GREEN}   check    ${NC}    Installs dependencies, Python (via pyenv), Cargo (via rustup), fonts (Geist & Nerdfonts), & firmware packages
  ${GREEN}i, install  ${NC}    Installs all apt (& alternative sources), flatpak, cargo, & binary (AppImage) packages
  ${GREEN}u, update   ${NC}    Updates & upgrades apt, flatpak, cargo packages. Updates other packages & cleans system (see \`${BLUE}config.yaml${NC}\` for details)
  ${GREEN}c, configure${NC}    Configures apps installed, restore / backup dotfiles via Stow (dotfile manager), & performs other system configs.
  ${GREEN}h, help     ${NC}    Print help information

${YELLOW}Configuration:${NC}
  Customise each command's behaviour by modifying the \`${BLUE}config.yaml${NC}\` file.
  The config schema of \`${BLUE}config.yaml${NC}\` is available at \`${BLUE}README.md${NC}\`.
  Sample configs are available in ${BLUE}<tides_path>/sample/${NC} directory.

${YELLOW}Example:${NC}
  ${tides_txt} ${CYAN}configure${NC}
EOF
}

# ----- SET CONSTANTS -----

# Set complex constants that require commands to be set.
# Globals:
#   EDIT
#   DISTRO
#   DESKTOP_ENVIRONMENT
#   VERSION_CODENAME: only if $UBUNTU_CODENAME exists
_set_constants() {
  EDIT=$(yq '.metadata.edit' "$CONFIG") # enables config file editing

  # get distro & set $DISTRO
  . /etc/os-release # contains operating system identification data
  local distro="$(yq '.metadata.distro' "$CONFIG")"
  if [[ $distro == "auto" ]]; then
    distro="$ID"
    _info_msg "Auto-detected & set distro to $distro"
  else
    _info_msg "Set distro to $distro as specified in config"
  fi
  DISTRO="$distro"

  # get desktop environment & set $DESKTOP_ENVIRONMENT
  local de="$(yq '.metadata.desktop_environment' "$CONFIG")"
  # detect DE modified from https://cgit.freedesktop.org/xdg/xdg-utils/tree/scripts/xdg-utils-common.in#n296
  if [[ $de == "auto" ]]; then
    case "$XDG_CURRENT_DESKTOP" in
      Cinnamon | X-Cinnamon) de=cinnamon ;;
      *GNOME*) de=gnome ;;
      *) _warning_msg "Unknown desktop environment" ;;
    esac
    if [[ $de != "auto" ]]; then
      _info_msg "Auto-detected & set desktop environment to $de"
    fi
  else
    _info_msg "Set desktop environment to $de as specified in config"
  fi
  DESKTOP_ENVIRONMENT="$de"

  if [[ -n $UBUNTU_CODENAME ]]; then
    # overwrite $VERSION_CODENAME in Ubuntu-based distros for adding repos which use $VERSION_CODENAME. Modifying this
    # system variable has no major consequences anyways
    # shellcheck disable=SC2034
    VERSION_CODENAME=$UBUNTU_CODENAME
  fi
}

# ----- OPTIONS -----

list_configs() {
  local configs
  # find all preset files, then filter out the parent dirs & file suffixes
  mapfile -t configs < <(
    find "$CONFIG_DIR" -type f | awk -F '[/.]' '{print $--NF}'
  )
  echo "${YELLOW}Available configs:${NC}"
  for config in "${configs[@]}"; do
    echo "  ${GREEN}$config${NC}"
  done
}

# Use config specified in config directory.
# Arguments:
#   config that exists in $CONFIG_DIR
set_config() {
  local config_file="${CONFIG_DIR}/$1.yaml"
  if [[ -f $config_file ]]; then
    _info_msg "Using $1 config (${config_file})"
    CONFIG=$config_file
  else
    _error_msg "Config selected \"$1\" does not exist"
  fi
}

# Use secrets file specified by user.
# Arguments:
#   secrets file as a path
set_secrets_file() {
  SECRETS="$(realpath "$1")"
  if [[ -f "$SECRETS" ]]; then
    yq '.gitconfig.name' "$SECRETS"
  else
    _error_msg "Secrets file selected \"$1\" does not exist"
  fi
}

# ----- COMMANDS -----

check() {
  _info_msg "Starting ${tides_txt} check..."

  if [[ $(yq '.config.check.snapDisabled' "$CONFIG") == true ]]; then
    _info_msg "Disabling snap"

    if command -v snap &>/dev/null; then
      _info_msg "Removing snap packages"
      mapfile -t snap_pkgs < <(
        snap list | grep -Ev '^(Name|bare|core[0-9][0-9]|snapd\s)' \
          | awk '{print $1}'
      )
      for pkg in "${snap_pkgs[@]}"; do
        # shellcheck disable=SC2086
        snap remove --purge $pkg
      done
      snap remove --purge "$(snap list | grep -o '^core[0-9][0-9]')"
      snap remove --purge bare
      snap remove --purge snapd
    fi

    if systemctl -q is-active snapd; then
      _info_msg "Stop & disable snap services"
      sudo systemctl stop snapd
      sudo systemctl disable snapd
    fi

    if command -v snapd &>/dev/null; then
      _info_msg "Removing snapd package from apt"
      sudo apt-get remove --purge -qq snapd
    fi

    if [[ -d ~/snap ]]; then
      _info_msg "Removing snap package directories"
      rm -rf ~/snap
    fi

    if [[ -d /snap || -d /var/snap || -d /var/lib/snapd ]]; then
      _info_msg "Removing leftover snap directories"
      sudo rm -rf /snap /var/snap /var/lib/snapd
    fi

    if [[ ! -f /etc/apt/preferences.d/nosnap.pref ]]; then
      _info_msg "Creating nosnap.pref to prevent snap from being reinstalled"
      sudo tee /etc/apt/preferences.d/nosnap.pref <<EOF >/dev/null
Package: snapd
Pin: release a=*
Pin-Priority: -10
EOF
    fi
  fi

  if [[ $(yq '.config.check.purgeEnabled' "$CONFIG") == true ]]; then
    _info_msg "Purging apt packages"

    local purge_pkgs # collect purge packages into array
    mapfile -t purge_pkgs < <(yq '.config.check.purge[]' "$CONFIG")
    for pkg in "${purge_pkgs[@]}"; do
      # shellcheck disable=SC2086
      sudo apt-get autoremove --purge -qy $pkg
    done

    if $EDIT; then
      _info_msg "Setting purgeEnabled to false"
      yq -i '.config.check.purgeEnabled = false' "$CONFIG"
    fi
  fi

  if [[ $(yq '.config.check.depsEnabled' "$CONFIG") == true ]]; then
    _info_msg "Installing dependencies"

    sudo apt-get update -qq
    # shellcheck disable=SC2046
    sudo apt-get install -qy $(yq '.config.check.deps[]' "$CONFIG")
  fi

  # installs pyenv, installs python according to version specified in $CONFIG
  if [[ $(yq '.config.check.python.pyenvCheck' "$CONFIG") == true ]]; then
    _info_msg "Running pyenv check"

    if ! command -v pyenv &>/dev/null; then
      _info_msg "Installing pyenv"
      if [[ ! -d ~/.pyenv ]]; then
        # NOTE: if pyenv dir exists but pyenv command fails, this means that pyenv isn't in PATH
        # install pyenv-installer https://github.com/pyenv/pyenv-installer &:
        #   - pyenv https://github.com/pyenv/pyenv
        #   - pyenv-doctor https://github.com/pyenv/pyenv-doctor
        #   - pyenv-update https://github.com/pyenv/pyenv-update
        #   - pyenv-virtualenv https://github.com/pyenv/pyenv-virtualenv
        curl https://pyenv.run | bash
      fi

      _info_msg "Temporarily exporting pyenv into PATH"
      export PATH="$HOME/.pyenv/bin:$PATH"
      eval "$(pyenv init -)"
      eval "$(pyenv virtualenv-init -)"
    fi

    local latest_py_ver=$(pyenv latest -k "$(yq '.config.check.python.version' "$CONFIG")")
    # install latest python version if pyenv python version is not latest.
    # covers test case where pyenv version-name is nonexistent
    if [[ $(pyenv version-name) != "$latest_py_ver" ]]; then
      # only install if python version exists but is not set to global
      if ! pyenv versions | grep "$latest_py_ver"; then
        _info_msg "Installing latest Python version $latest_py_ver"
        pyenv install "$(yq '.config.check.python.version' "$CONFIG")"
      fi
      _info_msg "Setting global Python version to $latest_py_ver"
      pyenv global "$(yq '.config.check.python.version' "$CONFIG")"
    fi
  fi

  if [[ $(yq '.config.check.rustupCheck' "$CONFIG") == true ]] \
    && ! command -v rustup &>/dev/null; then
    _info_msg "Installing rustup, rustc,  cargo"
    curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y
  fi

  # setup appimaged if appimaged service isn't running / doesn't exist
  if [[ $(yq '.config.check.appimagedCheck' "$CONFIG") == true ]] \
    && ! systemctl -q --user is-active appimaged; then
    _info_msg "Running appimaged check"
    # https://github.com/probonopd/go-appimage/tree/master/src/appimaged#initial-setup

    # remove pre-existing similar tools
    systemctl --user stop appimaged.service || true
    sudo apt-get remove -qy appimagelauncher || true

    # clear cache
    rm -rf "$HOME/.local/share/applications/appimage*"
    [ -f ~/.config/systemd/user/default.target.wants/appimagelauncherd.service ] \
      && rm ~/.config/systemd/user/default.target.wants/appimagelauncherd.service

    # download appimaged
    mkdir -p "$HOME/Applications"
    # get continuous release via GitHub api
    local browser_download_url=$(
      curl -sSL https://api.github.com/repos/probonopd/go-appimage/releases/tags/continuous \
        | yq '.assets[].browser_download_url | select(. == "*appimaged*x86_64.AppImage")'
    )
    curl -sSL -o "$HOME/Applications/appimaged.AppImage" \
      "$browser_download_url"

    # launch
    chmod +x "$HOME/Applications/appimaged.AppImage"
    "$HOME/Applications/appimaged.AppImage"
  fi

  # install Geist font
  if [[ $(yq '.config.check.geistFontEnabled' "$CONFIG") == true ]]; then
    _info_msg "Geist font check"
    if [[ ! -d "/usr/share/fonts/opentype/Geist/" ]]; then
      _info_msg "Downloading & installing Geist font"
      local font_url=$(
        curl -sSL https://api.github.com/repos/vercel/geist-font/releases/latest \
          | yq -p=j '.assets[].browser_download_url | select(. =="*Geist-*")'
      )
      # download Geist font
      curl -sSL -o Geist.zip "$font_url"
      unzip -o Geist.zip
      # install Geist opentype font
      sudo mv Geist-*/statics-otf/ /usr/share/fonts/opentype/Geist/
      _info_msg "Cleanup remnant files"
      rm -rf Geist.zip __MACOSX/ Geist-*
    else
      _info_msg "Geist font already exists"
    fi
    _info_msg "Reloading fc-cache"
    fc-cache -f

    if $EDIT; then
      _info_msg "Setting geistFontEnabled to false"
      yq -i '.config.check.geistFontEnabled = false' "$CONFIG"
    fi
  fi

  # install nerdfont
  if [[ $(yq '.config.check.nerdfontEnabled' "$CONFIG") == true ]]; then
    local font=$(yq '.config.check.nerdfont' "$CONFIG")
    _info_msg "Installing nerdfont $font"
    if [[ ! -d "/usr/share/fonts/$font" ]]; then
      _info_msg "Downloading $font"
      sudo mkdir -p "/usr/share/fonts/$font"
      curl -sSL \
        "https://github.com/ryanoasis/nerd-fonts/releases/latest/download/$font.tar.xz" \
        | sudo tar -xvJ -C "/usr/share/fonts/$font"
    fi
    _info_msg "Reloading fc-cache"
    fc-cache -f

    if $EDIT; then
      _info_msg "Setting nerdfontEnabled to false"
      yq -i '.config.check.nerdfontEnabled = false' "$CONFIG"
    fi
  fi
}

install() {
  _info_msg "Starting ${tides_txt} install"

  _set_constants
  [[ $(yq '.config.install.check' "$CONFIG") == true ]] && check

  # install apt packages if apt list has > 1 value
  if [[ $(yq '.config.install.aptEnabled' "$CONFIG") == true ]] \
    && [[ $(yq '.config.install.apt | length' "$CONFIG") -gt 0 ]]; then
    _info_msg "Installing apt packages"

    sudo apt-get update -qq
    # shellcheck disable=SC2046
    sudo apt-get install -qy $(yq '.config.install.apt[]' "$CONFIG")
  fi

  # install from apt alternative sources if aptAltSources list has > 1 value & flatpak is installed
  local no_of_alt_sources=$(yq '.config.install.aptAltSources | length' "$CONFIG")
  if [[ $(yq '.config.install.aptAltSourcesEnabled' "$CONFIG") == true ]] \
    && [[ $no_of_alt_sources -gt 0 ]]; then
    _info_msg "Installing apt packages from alternative sources"

    # setting up signing keys & repo entries for each source
    for ((i = 0; i < no_of_alt_sources; i++)); do
      local alt_pkg_obj=$(yq ".config.install.aptAltSources[$i]" "$CONFIG")
      local source_file_name=$(yq '.sourceFile' <<<"$alt_pkg_obj")

      # download gpg key from remote
      if [[ $(yq '.gpgKeyPath' <<<"$alt_pkg_obj") == *.asc ]]; then
        _info_msg "Downloading .asc key for $source_file_name"
        sudo curl -fsSL -o "$(yq '.gpgKeyPath' <<<"$alt_pkg_obj")" \
          "$(yq '.remoteGpgKey' <<<"$alt_pkg_obj")"
      elif [[ $(yq '.gpgKeyPath' <<<"$alt_pkg_obj") == *.gpg ]]; then
        _info_msg "Downloading & dearmoring .gpg key for $source_file_name"
        # dearmor if key is required to be in gpg format
        sudo curl -fsSL "$(yq '.remoteGpgKey' <<<"$alt_pkg_obj")" \
          | sudo gpg --dearmor --yes -o "$(yq '.gpgKeyPath' <<<"$alt_pkg_obj")"
      fi

      # add repo entry into sources.list.d
      local source_file_full_path="/etc/apt/sources.list.d/$source_file_name.list"
      _info_msg "Adding repo entry into sources.list.d for $source_file_name"
      eval echo "$(yq '.repo' <<<"$alt_pkg_obj")" \
        | sudo tee "$source_file_full_path" >/dev/null

      # perform pinning if pinning entry exists
      if [[ $(yq '.pinning' <<<"$alt_pkg_obj") != false ]]; then
        _info_msg "Performing pinning to prioritise $source_file_name"
        # perform pinning to prioritise
        local pref_file="/etc/apt/preferences.d/$source_file_name"
        yq '.pinning' <<<"$alt_pkg_obj" \
          | sudo tee "$pref_file" >/dev/null
      fi
    done

    # install packages
    _info_msg "Installing apt packages from alternative sources"
    sudo apt-get update -qq
    # disable shellcheck to enable installing multiple packages
    # shellcheck disable=SC2046
    sudo apt-get install -qy \
      $(yq '.config.install.aptAltSources[].packages[]' "$CONFIG")
  fi

  # install flatpaks if flatpak list has > 1 value
  if [[ $(yq '.config.install.flatpakEnabled' "$CONFIG") == true ]] \
    && [[ $(yq '.config.install.flatpak | length' "$CONFIG") -gt 0 ]] \
    && command -v flatpak &>/dev/null; then
    _info_msg "Installing flatpak packages"
    if ! flatpak remotes | grep -iq "^flathub"; then
      _info_msg "Adding flathub repository"
      flatpak remote-add \
        --if-not-exists flathub https://dl.flathub.org/repo/flathub.flatpakrepo
    fi
    # shellcheck disable=SC2046
    flatpak install -y flathub $(yq '.config.install.flatpak[]' "$CONFIG")
  fi

  # install cargo packages if cargo list has > 1 value & cargo is installed
  if [[ $(yq '.config.install.cargoEnabled' "$CONFIG") == true ]] \
    && [[ $(yq '.config.install.cargo | length' "$CONFIG") -gt 0 ]] \
    && command -v cargo &>/dev/null; then
    _info_msg "Installing cargo packages"
    local rust_pkgs
    mapfile -t rust_pkgs < <(yq '.config.install.cargo[]' "$CONFIG")
    for pkg in "${rust_pkgs[@]}"; do
      # disable SC2086 to enable installing with options
      # shellcheck disable=SC2086
      cargo install $pkg
    done
  fi

  # install binary packages if binaries list has > 1 value
  local no_of_binaries=$(yq '.config.install.binaries | length' "$CONFIG")
  if [[ $(yq '.config.install.binariesEnabled' "$CONFIG") == true ]] \
    && [[ $no_of_binaries -gt 0 ]]; then
    _info_msg "Installing binary packages"
    mkdir -p "$HOME/Applications"
    for ((i = 0; i < no_of_binaries; i++)); do
      local binary_obj=$(yq ".config.install.binaries[$i]" "$CONFIG")
      local binary_name=$(yq '.name' <<<"$binary_obj")
      # skip if binary exists
      if [[ -f "$HOME/Applications/$binary_name" ]]; then
        _info_msg "$binary_name already exists"
        continue
      fi
      # install AppImage
      if [[ $binary_name == *.AppImage ]]; then
        _info_msg "$binary_name is an AppImage"
        local download_url="$(yq '.url' <<<"$binary_obj")"
        # execute string as subshell if subshell detected
        if grep -Eq '\$\(.*\)' <<<"$(yq '.url' <<<"$binary_obj")"; then
          download_url="$(eval echo "$(yq '.url' <<<"$binary_obj")")"
        fi
        _info_msg "Installing $binary_name"
        curl -fsSL -o "$HOME/Applications/$binary_name" "$download_url"
        chmod +x "$HOME/Applications/$binary_name"
      fi
    done
  fi

  _success_msg "Finished ${tides_txt} install"
}

update() {
  _info_msg "Starting ${tides_txt} update"

  _set_constants
  [[ $(yq '.config.update.check' "$CONFIG") == true ]] && check

  if [[ $(yq '.config.update.apt.apt' "$CONFIG") == true ]]; then
    _info_msg "Updating & upgrading apt packages"
    sudo apt-get -qq update
    sudo apt-get -qy upgrade
    # aptFull removes old archive files & unused packages with their config files
    if [[ $(yq '.config.update.apt.aptFull' "$CONFIG") == true ]]; then
      _info_msg "Cleaning apt cache"
      sudo apt-get -qy dist-upgrade
      sudo apt-get -qy autoclean
      sudo apt-get -qy --purge autoremove
    fi
  fi

  # update flatpak
  if [[ $(yq '.config.update.flatpak' "$CONFIG") == true ]] \
    && command -v flatpak &>/dev/null; then
    _info_msg "Updating flatpaks"
    flatpak update -y
  fi

  # update python
  if [[ $(yq '.config.update.python' "$CONFIG") == true ]] \
    && command -v pyenv &>/dev/null; then
    _info_msg "Updating Pyenv"
    pyenv update

    # update python
    local latest_py_ver=$(pyenv latest -k "$(yq '.config.check.python.version' "$CONFIG")")
    if [[ $(pyenv version-name) != "$latest_py_ver" ]]; then
      _info_msg "Installing Python $latest_py_ver"
      pyenv install "$(yq '.config.check.python.version' "$CONFIG")"
      pyenv global "$(yq '.config.check.python.version' "$CONFIG")"
    else
      _info_msg "Python version is already the latest"
    fi

    _info_msg "Upgrading pip"
    local py_ver="python$(yq '.config.check.python.version' "$CONFIG")"
    $py_ver -m pip install --upgrade pip
  fi

  # update cargo
  if [[ $(yq '.config.update.cargo' "$CONFIG") == true ]] \
    && command -v rustup &>/dev/null \
    && command -v cargo &>/dev/null; then
    _info_msg "Updating rustup"
    rustup update
    _info_msg "Updating Rust packages"
    cargo install-update -a
  fi

  # update yq
  if [[ $(yq '.config.update.other.yq' "$CONFIG") == true ]]; then
    _info_msg "Updating yq"
    # get local yq version & parse it
    local_yq_ver=$(yq --version | cut -d ' ' -f 4)
    # get latest yq version
    latest_yq_ver=$(
      curl -sSL https://api.github.com/repos/mikefarah/yq/releases/latest \
        | yq '.tag_name'
    )
    if [[ $local_yq_ver != "$latest_yq_ver" ]]; then
      _info_msg "Downloading & installing latest yq"
      sudo curl -sSL -o /usr/bin/yq \
        https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
      sudo chmod +x /usr/bin/yq
    else
      _info_msg "yq $local_yq_ver is already the latest"
    fi
  fi

  # zellij delete all other sessions, including exited ones
  if [[ $(yq '.config.update.other.zellijClear' "$CONFIG") == true ]] \
    && command -v zellij &>/dev/null; then
    _info_msg "Deleting all other Zellij sessions"
    zellij delete-all-sessions -y
  fi

  _success_msg "Finished ${tides_txt} update"
}

configure() {
  _info_msg "Starting ${tides_txt} configuration"

  _set_constants
  [[ $(yq '.config.configure.check' "$CONFIG") == true ]] && check

  # dotfile manager implementation via Stow
  if [[ $(yq '.config.configure.dotfilesEnabled' "$CONFIG") == true ]] \
    && [[ $(yq '.config.configure.dotfiles.dotfiles | length' "$CONFIG") -gt 0 ]] \
    && command -v stow &>/dev/null; then
    _info_msg "Configuring dotfiles via Stow"
    local packages
    mapfile -t packages < <(
      yq -r '.config.configure.dotfiles.dotfiles[]' "$CONFIG"
    )
    for pkg in "${packages[@]}"; do
      _info_msg "Stowing $pkg"
      # symlink between tides & actual dotfiles
      # --no-folding stows individual files instead of directories
      # --adopt replaces tides' dotfiles with system ones. this is needed as
      # Stow throws an error if there are existing system dotfiles.
      # however, tides' dotfiles will be lost, & this is mitigated if
      # .config.configure.stowMode is set to "override".
      stow --no-folding --adopt -v -d "dotfiles/" -t "$HOME" "$pkg"
      # override system files with tides' dotfiles
      if [[ $(yq -r '.config.configure.dotfiles.stowMode' "$CONFIG") == "override" ]] \
        && git status --porcelain --untracked-files=no $DOTFILES \
        | grep -q "$pkg"; then
        _info_msg "Overriding system config files with ${tides_txt}' dotfiles"
        # NOTE: commit any new changes made to dotfiles as they will be reset
        # if there are any changes detected.
        # TODO: explore a cleaner option than git restore
        git restore "$DOTFILES/$pkg/"
      fi
    done
  fi

  # generate GPG key
  if [[ $(yq '.config.configure.apps.gpg.genKey' "$CONFIG") == true ]]; then
    _info_msg "Generating GPG key"
    gpg --batch --full-gen-key <<EOF
%echo Generating a full key
Key-Type: RSA
Key-Length: 4096
Expire-Date: 0
Name-Real: $(yq '.gpg.name' "$SECRETS")
Name-Email: $(yq '.gpg.email' "$SECRETS")
Name-Comment: $(yq '.gpg.comment' "$SECRETS")
Passphrase: $(yq '.gpg.passphrase' "$SECRETS")
%commit
EOF

    if $EDIT; then
      yq -i '.config.configure.apps.gpg.genKey = false' "$CONFIG"
    fi
  fi

  # setup git user field in gitconfig via ~/.gitconfig.local
  if [[ $(yq '.config.configure.apps.git.userInfo' "$CONFIG") == true ]]; then
    _info_msg "Setting up \`.gitconfig.local\`"
    tee ~/.gitconfig.local <<EOF >/dev/null
[user]
    name = $(yq '.gitconfig.name' "$SECRETS")
    email = $(yq '.gitconfig.email' "$SECRETS")
EOF
    # add signingkey if field exists
    if [[ -n $(yq '.gitconfig.signingkey' secrets.yaml) ]]; then
      _info_msg "Adding signing key"
      tee -a ~/.gitconfig.local <<EOF >/dev/null
    signingkey = $(yq '.gitconfig.signingkey' "$SECRETS")
EOF
    fi
  fi

  # setup Alacritty
  if [[ $(yq '.config.configure.apps.alacritty' "$CONFIG") == true ]] \
    && command -v alacritty &>/dev/null; then
    _info_msg "Configuring Alacritty"

    # add desktop icon
    if [[ ! -f /usr/share/pixmaps/Alacritty.svg ]]; then
      _info_msg "Adding Alacritty icon"
      sudo curl -fsLS --create-dirs -o /usr/share/pixmaps/Alacritty.svg \
        https://github.com/alacritty/alacritty/raw/master/extra/logo/alacritty-term.svg
    fi

    # add desktop entry
    if [[ ! -f /usr/share/applications/Alacritty.desktop ]]; then
      _info_msg "Adding desktop entry"
      sudo curl -fsLS --create-dirs -o /usr/share/applications/Alacritty.desktop \
        https://github.com/alacritty/alacritty/raw/master/extra/linux/Alacritty.desktop
      sudo update-desktop-database
    fi
  fi

  # setup docker
  if [[ $(yq '.config.configure.apps.docker' "$CONFIG") == true ]] \
    && command -v docker &>/dev/null; then
    _info_msg "Setting up docker"
    # https://docs.docker.com/engine/install/linux-postinstall/

    # manage docker as non-root user
    if ! id --name --groups "$USER" | grep docker &>/dev/null; then
      _info_msg "Adding user to docker group to allow user to execute docker commands"
      # create docker group
      sudo groupadd -f docker
      # add user to docker group
      sudo usermod -aG docker "$USER"
      # change group ID to docker to activate change in current shell
      newgrp docker
    fi

    # configure docker to start on boot (& right now) with systemd
    _info_msg "Configuring docker to start on boot"
    if ! systemctl -q is-active docker.service; then
      sudo systemctl enable --now docker.service
    fi
    if ! systemctl -q is-active containerd.service; then
      sudo systemctl enable --now containerd.service
    fi

    # use local logging driver to prevent disk-exhaustion
    # local logging driver performs log-rotation & compresses log files by
    # default.
    # https://docs.docker.com/config/containers/logging/configure/
    # https://docs.docker.com/config/containers/logging/local/
    if [[ "$(yq -r '.log-driver' /etc/docker/daemon.json)" != "local" ]]; then
      _info_msg "Using local logging driver to prevent disk-exhaustion"
      yq -p=j -n -o=j \
        '{"log-driver":"local","log-opts":{"max-size":"10m"}}' \
        | sudo tee /etc/docker/daemon.json >/dev/null
    fi
  fi

  # setup virtualbox
  if [[ $(yq '.config.configure.apps.virtualbox' "$CONFIG") == true ]] \
    && command -v virtualbox &>/dev/null; then
    # to allow virtualbox to access USB devices, add $USER to vboxusers group
    # https://www.virtualbox.org/manual/ch02.html
    if ! id --name --groups "$USER" | grep vboxusers &>/dev/null; then
      _info_msg "Adding user to vboxusers group to allow user to execute virtualbox commands"
      # create vboxusers group
      sudo groupadd -f vboxusers
      # add user to vboxusers group
      sudo usermod -aG vboxusers "$USER"
      # change group ID to vboxusers to activate change in current shell
      newgrp vboxusers
    fi
  fi

  # install vscodium extensions
  if [[ $(yq '.config.configure.apps.vscodium.extensionsEnabled' "$CONFIG") == true ]] \
    && [[ $(yq '.config.configure.apps.vscodium.extensions | length' "$CONFIG") -gt 0 ]]; then
    local extensions
    mapfile -t extensions < <(
      yq -r '.config.configure.apps.vscodium.extensions[]' "$CONFIG"
    )
    for ext in "${extensions[@]}"; do
      # install vscodium extensions
      # shellcheck disable=SC2086
      codium --install-extension $ext
    done
  fi

  # optimisations
  if [[ $(yq ".config.configure.optimisationsEnabled" "$CONFIG") == true ]]; then
    _info_msg "Configuring optimisations"
    if [[ $(yq ".config.configure.optimisations.auto-cpufreq" "$CONFIG") == true ]]; then
      _info_msg "Configuring auto-cpufreq"
      if ! command -v auto-cpufreq &>/dev/null; then
        _info_msg "Installing auto-cpufreq"
        git clone https://github.com/AdnanHodzic/auto-cpufreq.git
        cd auto-cpufreq && sudo ./auto-cpufreq-installer
        cd ..
        rm -rf auto-cpufreq
      fi
      if systemctl is-active --quiet auto-cpufreq; then
        _info_msg "auto-cpufreq daemon is already running"
      else
        sudo auto-cpufreq --install
      fi
    fi
  fi

  # desktop-environment specific configurations
  if [[ $(yq ".config.configure.DEConfEnabled" "$CONFIG") == true ]]; then
    _info_msg "Configuring desktop environment"
    # cinnamon settings
    if [[ $DESKTOP_ENVIRONMENT == "cinnamon" ]]; then
      if [[ $(yq ".config.configure.DEConf.cinnamon.setDefaultTerm" "$CONFIG") == true ]]; then
        local term=$(yq ".config.configure.DEConf.cinnamon.defaultTerm" "$CONFIG")
        _info_msg "Setting default terminal to $term"
        gsettings set org.cinnamon.desktop.default-applications.terminal exec "$term"
        gsettings set org.cinnamon.desktop.default-applications.terminal exec-arg ''
      fi
    fi

    # gnome settings
    if [[ "$DESKTOP_ENVIRONMENT" == "gnome" ]]; then
      if [[ $(yq ".config.configure.DEConf.gnome.setDefaultTerm" "$CONFIG") == true ]]; then
        local term=$(yq ".config.configure.DEConf.gnome.defaultTerm" "$CONFIG")
        _info_msg "Setting default terminal to $term"
        gsettings set org.gnome.desktop.default-applications.terminal exec "$term"
        gsettings set org.gnome.desktop.default-applications.terminal exec-arg ''
      fi
    fi
  fi

  _success_msg "Finished ${tides_txt} configuration"
}

# ----- MAIN -----

main() {
  # PRINT FUNCTIONS
  _colours true

  # install curl if not installed
  if ! command -v curl &>/dev/null; then
    _info_msg "Installing curl"
    sudo apt-get install -qq curl
  fi

  # download & install yq if not installed
  if ! command -v yq &>/dev/null; then
    _info_msg "Installing yq"
    sudo curl -sSL -o /usr/bin/yq \
      https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
    sudo chmod +x /usr/bin/yq
  fi

  [[ $# -gt 0 ]] || {
    _usage
    _error_msg "No argument(s)"
  }

  while [[ $# -gt 0 ]]; do
    case $1 in
      # OPTIONS
      --no-colour) _colours false ;;
      --list-configs) list_configs ;;
      -c | --config)
        set_config "$2"
        shift
        ;;
      --config-file)
        set_config_file "$2"
        shift
        ;;
      --secrets-file)
        set_secrets_file "$2"
        shift
        ;;
      -v | --version) echo "tides $(yq '.version' "$CONFIG")" ;;
      # COMMANDS
      check) check ;;
      install) install ;;
      update) update ;;
      configure) configure ;;
      -h | --help | h | help) _usage ;;
      *)
        _usage
        _error_msg "Invalid argument(s)"
        ;;
    esac
    shift
  done
}

main "$@"
