#!/usr/bin/env bash
set -euo pipefail

# global variables
readonly COZYDOT_VERSION=0.0.1
CONFIG="$(dirname "$(realpath "$0")")/configs/default.yaml"
# set in _set_global_var()
DISTRO="" UPSTREAM_DISTRO="" DESKTOP_ENVIRONMENT=""

# ----- PRINT FUNCTIONS -----

# Set text colours if supported.
# Arguments:
#   $1: boolean indicating if colours is enabled
colours() {
  NC="" BOLD="" RED="" GREEN="" YELLOW="" BLUE="" MAGENTA="" CYAN=""
  if [[ $(tput colors) -ge 8 ]] && [[ $1 == true ]]; then
    NC=$(tput sgr0) BOLD=$(tput bold) # text reset (select graphic representation default)
    RED=$(tput setaf 1) GREEN=$(tput setaf 2) YELLOW=$(tput setaf 3) BLUE=$(tput setaf 4) MAGENTA=$(tput setaf 5) CYAN=$(tput setaf 6)
  fi
  cozydot_txt="${RED}c${YELLOW}o${GREEN}z${CYAN}y${BLUE}d${MAGENTA}o${RED}t${NC}"
}

_info_msg() { printf "%s\n" "${BOLD}${BLUE}Info:${NC} $1"; }

_success_msg() { printf "%s\n" "${BOLD}${GREEN}Success:${NC} $1"; }

_warning_msg() { printf "%s\n" "${BOLD}${YELLOW}Warning:${NC} $1"; }

_error_msg() { printf "%s\n" "${BOLD}${RED}Error:${NC} $1" && exit 1; }

_usage() {
  cat <<EOF
$cozydot_txt is an automated ${BOLD}post-install${NC}, ${BOLD}update${NC}, & ${BOLD}config (dotfile) manager${NC} for Linux

${YELLOW}Usage:${NC} ${cozydot_txt} ${CYAN}[Options]${NC} ${CYAN}[Command]${NC}

${YELLOW}Options:${NC}
  ${GREEN}-n, --no-colour      ${NC} Do not output any colour. Useful when redirecting output to a logfile
  ${GREEN}-c, --config <CONFIG>${NC} Specify a yaml config file that exists in ${BLUE}~/.cozydot/configs/${NC}
  ${GREEN}    --list-configs   ${NC} List all available configs in ${BLUE}~/.cozydot/configs/${NC} directory
  ${GREEN}-h, --help           ${NC} Print help information
  ${GREEN}-V, --version        ${NC} Print version information

${YELLOW}Commands:${NC}
  ${GREEN}   check    ${NC} Purges bloat (disabled by default) & installs dependencies. Installs Python (via
               pyenv), Cargo (via rustup), appimaged (AppImage integration daemon), & Nerdfonts
  ${GREEN}i, install  ${NC} Installs all apt (& alternative sources), flatpak, cargo, binary (AppImage)
               packages, & programming languages (node & golang)
  ${GREEN}u, update   ${NC} Updates & upgrades apt, flatpak, cargo packages. Updates other packages & clears
               Zellij cache (see ${BLUE}~/.cozydot/configs/default.yaml${NC} for details)
  ${GREEN}c, configure${NC} Restore / backup dotfiles via Stow (dotfile manager), configures apps installed,
               customise desktop environment (Cinnamon / GNOME)

${YELLOW}Configuration:${NC}
  Customise each command action by modifying the config (default: ${BLUE}~/.cozydot/configs/default.yaml${NC}).
  The full config schema of ${cozydot_txt} is available in ${BLUE}README.md${NC}.
  Preset configs are available in ${BLUE}~/.cozydot/configs/${NC} directory.
  Add new configs in ${BLUE}~/.cozydot/configs/${NC} or list them with ${cozydot_txt} ${CYAN}--list-configs${NC}

${YELLOW}Example:${NC} ${cozydot_txt} ${CYAN}--config${NC} vm ${CYAN}install${NC}

${YELLOW}Project Homepage:${NC} ${MAGENTA}https://github.com/adoreblvnk/cozydot${NC}

EOF
}

# ----- SET GLOBAL VARIABLES -----

# Set complex global variables that require commands to be set.
# Globals:
#   DISTRO
#   UPSTREAM_DISTRO: parent distro (eg Ubuntu is the upstream of Mint)
#   DESKTOP_ENVIRONMENT
#   VERSION_CODENAME: only if $UBUNTU_CODENAME exists
_set_global_var() {
  _info_msg "Using ${GREEN}$(awk -F '[./]' '{print $(NF-1)}' <<<"$CONFIG")${NC} config file"

  # get distro & set $DISTRO
  source /etc/os-release # contains operating system identification data
  DISTRO="$(yq '.metadata.distro' "$CONFIG")"
  if [[ $DISTRO == "auto" ]]; then
    DISTRO="$ID"
    local distro_auto=" (auto)"
  fi
  case "$DISTRO" in
    # https://github.com/which-distro/os-release
    ubuntu | linuxmint | pop | zorin | Deepin) UPSTREAM_DISTRO=ubuntu ;;
    debian | kali | tails) # shellcheck disable=SC2034
      UPSTREAM_DISTRO=debian ;;
    *) _error_msg "Unsupported distro detected / in config ($DISTRO)" ;;
  esac

  # get desktop environment & set $DESKTOP_ENVIRONMENT
  DESKTOP_ENVIRONMENT="$(yq '.metadata.DE' "$CONFIG")"
  # detect DE modified from https://cgit.freedesktop.org/xdg/xdg-utils/tree/scripts/xdg-utils-common.in#n296
  if [[ $DESKTOP_ENVIRONMENT == "auto" ]]; then
    case "${XDG_CURRENT_DESKTOP:-}" in
      *GNOME*) DESKTOP_ENVIRONMENT=gnome ;;
      Cinnamon | X-Cinnamon) DESKTOP_ENVIRONMENT=cinnamon ;;
      *) _warning_msg "Unsupported desktop environment detected (${XDG_CURRENT_DESKTOP:-})" ;;
    esac
    local de_auto=" (auto)"
  fi
  case $DESKTOP_ENVIRONMENT in
    gnome) ;;
    cinnamon) _warning_msg "Cinnamon has stopped receiving updates" ;;
    *) _warning_msg "${cozydot_txt} ${CYAN}configure${NC} will ${RED}not${NC} configure this unsupported desktop environment ($DESKTOP_ENVIRONMENT)" ;;
  esac

  # substitute nothing if auto is unset
  _info_msg "Distro: ${DISTRO}${distro_auto:-}, Desktop Environment: ${DESKTOP_ENVIRONMENT}${de_auto:-}"

  if [[ -n ${UBUNTU_CODENAME:-} ]]; then
    _info_msg "Ubuntu-based distro detected. overwriting \$VERSION_CODENAME to $UBUNTU_CODENAME"
    # Overwrite $VERSION_CODENAME to use $UBUNTU_CODENAME for adding repos in
    # config. No major consequences anyways
    VERSION_CODENAME="$UBUNTU_CODENAME"
  fi
}

# ----- HELPERS -----

# Downloads / updates golang.
# Arguments:
#   $1: go version. must be either "latest" or <major>.<minor>.<patch>
_dl_golang() {
  if [ -z "${1:-}" ]; then _error_msg "no value supplied to _dl_golang"; fi
  local latest_go=$1
  if [[ $1 == "latest" ]]; then
    latest_go="$(
      curl -sSL "https://go.dev/dl/?mode=json" | yq '.[0].version' | cut -c 3-
    )"
  fi
  if ! command -v go &>/dev/null \
    || [[ "$(go version | cut -d ' ' -f 3)" != "go$latest_go" ]]; then
    _info_msg "Downloading golang $latest_go"
    curl -sSL -o "/tmp/go.tar.gz" \
      "https://go.dev/dl/go${latest_go}.linux-amd64.tar.gz"
    sudo rm -rf /usr/local/go && sudo tar -C /usr/local -xzf /tmp/go.tar.gz
    source ~/.bashrc
  fi
  _info_msg "Golang (go $(go version | cut -d ' ' -f 3 | cut -c 3-)) installed"
}

# Downloads / updates Node via nvm. Requires nvm to be installed.
# Arguments:
#   $1: node version. format must either be "latest" | <major>[.<minor>[.<patch>]]
_dl_node() {
  if [ -z "${1:-}" ]; then _error_msg "no value supplied to _dl_node"; fi
  if ! command -v nvm &>/dev/null; then
    if [[ ! -f ~/.nvm/nvm.sh ]]; then
      _info_msg "Installing nvm" # install script adds nvm to PATH if needed
      curl -ssLo- https://github.com/nvm-sh/nvm/raw/master/install.sh | bash
    fi
    source ~/.nvm/nvm.sh # source to activate nvm for scripts
  fi
  local node_ver="$1"
  # set node_ver to "--lts" if value is "latest"
  [[ $1 == "latest" ]] && node_ver="--lts"
  # get latest node ver specified from nvm. TODO: potentially flaky, investigate stability
  local latest_node_ver=$(nvm version-remote "$node_ver")
  if [[ "$(nvm current)" != "$latest_node_ver" ]]; then
    _info_msg "Installing node $latest_node_ver"
    nvm install "$node_ver"
  fi
  _info_msg "nvm $(nvm -v), node $(node -v), npm $(npm -v) installed"
}

# ----- OPTIONS -----

# Use config specified in configs directory.
# Arguments:
#   $1: name of config yaml file
set_config() {
  CONFIG="$(dirname "$(realpath "$0")")/configs/$1.yaml"
  if [[ ! -f $CONFIG ]]; then
    _error_msg "Config selected ${GREEN}$1${NC} does not exist"
  fi
}

list_configs() {
  local configs
  # find all preset files, then filter out the parent dirs & file suffixes
  mapfile -t configs < <(
    find "$(dirname "$(realpath "$0")")/configs" -type f \
      | awk -F '[/.]' '{print $(NF-1)}'
  )
  printf "%s\n" "${YELLOW}Available configs:${NC}"
  for config in "${configs[@]}"; do
    printf "%s\n" "  ${GREEN}$config${NC}: $(yq '.metadata.description' "$(dirname "$(realpath "$0")")/configs/$config.yaml")"
  done
}

get_version() { printf "%s\n" "$cozydot_txt $COZYDOT_VERSION" && exit; }

# ----- COMMANDS -----

check() {
  _info_msg "Starting ${cozydot_txt} check..."

  if [[ ! -L ~/.bashrc ]]; then
    _info_msg "Copying $cozydot_txt .bashrc"
    rm -f ~/.bashrc && cp dotfiles/bash/.bashrc ~/.bashrc
  fi

  # setup ubuntu: remove snaps, install ubuntu-restricted-extras, disable auto upgrades
  if [[ $(yq '.check.distroCfg' "$CONFIG") == true ]] \
    && [[ $DISTRO == "ubuntu" ]]; then
    # remove snap modified from https://www.baeldung.com/linux/snap-remove-disable
    if command -v snap &>/dev/null; then
      _info_msg "Removing snap packages"
      # exclude bare, core20, snapd first as snap depends on these
      mapfile -t snap_pkgs < <(
        snap list 2>/dev/null \
          | grep -Ev '^(Name|bare|core[0-9][0-9]|snapd\s)' | awk '{print $1}'
      )
      for pkg in "${snap_pkgs[@]}"; do snap remove --purge "$pkg"; done
      # remove core20. NOTE: this number can change
      if snap list 2>/dev/null | grep -q '^core[0-9][0-9]'; then
        sudo snap remove --purge \
          "$(snap list 2>/dev/null | grep -o '^core[0-9][0-9]')"
      fi
      sudo snap remove --purge bare
      sudo snap remove --purge snapd
    fi
    if systemctl -q is-active snapd; then
      _info_msg "Stop & disable snap services"
      sudo systemctl stop snapd
      sudo systemctl disable snapd
    fi
    if command -v snap &>/dev/null; then
      # we need to run this after disabling service from systemctl
      _info_msg "Removing snapd package from apt"
      sudo apt-get purge -qq snapd
    fi
    if systemctl -q is-active snapd.mounts-pre.target; then
      # no need to disable, this is a cleanup of system boot of a non-existing process
      _info_msg "Stop snapd.mounts-pre.target, started by system boot"
      sudo systemctl stop snapd.mounts-pre.target
    fi
    if [[ -d ~/snap || -d /snap || -d /var/snap || -d /var/lib/snapd ]]; then
      _info_msg "Removing snap package directories / leftover snap directories"
      sudo rm -rf ~/snap /snap /var/snap /var/lib/snapd
    fi
    sudo tee /etc/apt/preferences.d/nosnap.pref <<EOF >/dev/null
Package: snapd
Pin: release a=*
Pin-Priority: -10
EOF

    if ! dpkg -s ubuntu-restricted-extras &>/dev/null; then
      _info_msg "Installing ubuntu-restricted-extras"
      sudo apt-get update -qq
      sudo apt-get install -qq ubuntu-restricted-extras
    fi

    # disabling auto upgrades
    if command -v unattended-upgrades &>/dev/null; then
      _info_msg "Uninstalling unattended-upgrades package"
      sudo apt-get purge -qq unattended-upgrades >/dev/null
    fi
    sudo tee /etc/apt/apt.conf.d/20auto-upgrades <<EOF >/dev/null
APT::Periodic::Update-Package-Lists "0";
APT::Periodic::Unattended-Upgrade "0";
EOF

  # setup mint: install multimedia codecs
  elif [[ $(yq '.check.distroCfg' "$CONFIG") == true ]] \
    && [[ $DISTRO == "linuxmint" ]]; then
    if ! dpkg -s mint-meta-codecs &>/dev/null; then
      _info_msg "Installing mint-meta-codecs"
      sudo apt-get update -qq && sudo apt-get install -qq mint-meta-codecs
    fi

  # setup debian: enable sudo for user, add contrib + non-free sources
  elif [[ $(yq '.check.distroCfg' "$CONFIG") == true ]] \
    && [[ $DISTRO == "debian" ]]; then
    if ! getent group sudo | grep -q "$USER"; then
      _warning_msg "Adding $USER to sudo group. Restart to use sudo"
      adduser "$USER" sudo
    fi

    DISTRIBUTION=$VERSION_CODENAME
    sudo tee /etc/apt/sources.list <<EOF >/dev/null
deb http://deb.debian.org/debian $DISTRIBUTION main contrib non-free non-free-firmware
deb-src http://deb.debian.org/debian $DISTRIBUTION main contrib non-free non-free-firmware

deb http://deb.debian.org/debian-security ${DISTRIBUTION}-security main contrib non-free non-free-firmware
deb-src http://deb.debian.org/debian-security ${DISTRIBUTION}-security main contrib non-free non-free-firmware

# $DISTRIBUTION updates, to get updates before a point release is made;
# see https://www.debian.org/doc/manuals/debian-reference/ch02.en.html#_updates_and_backports
deb http://deb.debian.org/debian ${DISTRIBUTION}-updates main contrib non-free non-free-firmware
deb-src http://deb.debian.org/debian ${DISTRIBUTION}-updates main contrib non-free non-free-firmware
EOF

  else
    _warning_msg "$cozydot_txt only supports Ubuntu / Debian / Linux Mint. $DISTRO unsupported."
  fi

  if [[ $(yq '.check.purge | tag' "$CONFIG") == "!enabled" ]]; then
    local purge_pkgs # collect purge packages into array
    mapfile -t purge_pkgs < <(yq '.check.purge[]' "$CONFIG")
    for pkg in "${purge_pkgs[@]}"; do
      if dpkg-query -W "$pkg" &>/dev/null; then
        _info_msg "Purging $pkg"
        sudo apt-get purge -qq "$pkg" >/dev/null
      fi
    done
    # disable purge after 1st run to prevent purging properly installed packages
    yq -i '.check.purge tag = "!disabled"' "$CONFIG"
  fi

  # install dependency packages
  if [[ $(yq '.check.deps | tag' "$CONFIG") == "!enabled" ]]; then
    local apt_pkgs
    mapfile -t apt_pkgs < <(yq '.check.deps[]' "$CONFIG")
    sudo apt-get update -qq
    for pkg in "${apt_pkgs[@]}"; do
      if ! dpkg-query -W "$pkg" &>/dev/null; then
        _info_msg "Installing dependency package $pkg"
        sudo apt-get install -qq "$pkg"
      fi
    done
  fi

  # installs pyenv, installs python according to version specified in $CONFIG
  if [[ $(yq '.check.pyenv | tag' "$CONFIG") == "!enabled" ]]; then
    if ! command -v pyenv &>/dev/null; then
      _info_msg "Installing pyenv"
      source ~/.bashrc
      if [[ ! -d ~/.pyenv ]]; then
        # NOTE: if pyenv dir exists but pyenv command fails, this means that pyenv isn't in PATH
        # install pyenv-installer https://github.com/pyenv/pyenv-installer
        #   - pyenv https://github.com/pyenv/pyenv
        #   - pyenv-doctor https://github.com/pyenv/pyenv-doctor
        #   - pyenv-update https://github.com/pyenv/pyenv-update
        #   - pyenv-virtualenv https://github.com/pyenv/pyenv-virtualenv
        curl https://pyenv.run | bash
      else
        _error_msg "pyenv directory already exists, but pyenv command not found. Please add ~/.pyenv/bin to PATH"
      fi
    else
      if [[ $(yq '.check.pyenv.update' "$CONFIG") == true ]]; then
        _info_msg "Updating pyenv"
        pyenv update &>/dev/null
      fi
      _info_msg "pyenv $(pyenv --version | cut -d ' ' -f 2) is already installed"
    fi

    # install latest python version if pyenv python version is not latest
    local latest_py=$(pyenv latest -k "$(yq '.check.pyenv.version' "$CONFIG")")
    if [[ $(pyenv version-name) != "$latest_py" ]]; then
      # install if latest ver is not in system (ie not previously installed)
      if ! pyenv versions | grep "$latest_py"; then
        _info_msg "Installing latest Python version $latest_py"
        pyenv install "$latest_py"
      fi
      _info_msg "Setting global Python version to $latest_py"
      pyenv global "$latest_py"
    else
      _info_msg "Python $(pyenv version-name) is already the latest"
    fi

    if [[ $(yq '.check.pyenv.pip' "$CONFIG") == true ]]; then
      local py_ver="python$(yq '.check.pyenv.version' "$CONFIG")"
      $py_ver -m pip install --upgrade pip
      _info_msg "Pip version $($py_ver -m pip -V | cut -d ' ' -f 2) installed"
    fi
  fi

  # installs uv, optionally pins to a specific version of Python
  if [[ $(yq '.check.uv | tag' "$CONFIG") == "!enabled" ]]; then
    if ! command -v uv &>/dev/null; then
      _info_msg "Installing uv, a Python package & project manager"
      curl -LsSf https://astral.sh/uv/install.sh | sh
      source ~/.bashrc
    else
      _info_msg "uv $(uv -V | cut -d ' ' -f 2) already installed"
      uv self update -q
    fi

    if [[ $(yq '.check.uv.version | tag' "$CONFIG") == "!enabled" ]]; then
      local py_ver="$(yq '.check.uv.version' "$CONFIG")"
      # use managed-python flag to exclude system Python
      local local_py_ver="$(uv python find --managed-python --show-version "$py_ver")"
      # NOTE: if py_ver is set to major version only (eg 3)
      local latest_py_ver="$(uv python list "$py_ver" | grep -Eo '[0-9]+\.[0-9]+\.[0-9]+' | head -n 1)"
      # this also triggers if local_py_ver is not set
      if [[ $local_py_ver != "$latest_py_ver" ]]; then
        _info_msg "Installing Python $latest_py_ver"
        uv python install "$latest_py_ver"
      else
        _info_msg "Python $latest_py_ver is already the latest"
      fi
    fi
  fi

  if [[ $(yq '.check.rustupCheck' "$CONFIG") == true ]]; then
    if ! command -v rustup &>/dev/null; then
      _info_msg "Installing Rustup toolchain (rustup, rustc, cargo)"
      curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y
      source ~/.bashrc
    fi
    _info_msg "Rustup $(rustup -V 2>/dev/null | cut -d ' ' -f 2) toolchain already installed"
  fi

  # setup appimaged if appimaged service isn't running or appimage.cleanInstall is specified
  if [[ $(yq '.check.appimaged' "$CONFIG") == true ]]; then
    if ! systemctl --user -q is-active appimaged; then
      # https://github.com/probonopd/go-appimage/tree/master/src/appimaged#initial-setup
      _info_msg "Installing appimaged"

      # remove pre-existing similar tools
      systemctl --user stop appimaged.service || true
      sudo apt-get remove -qy appimagelauncher &>/dev/null || true

      # clear cache
      rm -rf "$HOME/.local/share/applications/appimage*"
      rm -f ~/.config/systemd/user/default.target.wants/appimagelauncherd.service

      # download appimaged
      mkdir -p ~/Applications
      # get continuous release via GitHub api
      curl -sSL -o ~/Applications/appimaged.AppImage \
        "$(curl -sSL https://api.github.com/repos/probonopd/go-appimage/releases/tags/continuous \
          | yq '.assets[].browser_download_url | select(. == "*appimaged*x86_64.AppImage")')"

      # launch
      chmod +x ~/Applications/appimaged.AppImage
      ~/Applications/appimaged.AppImage
    else
      _info_msg "Appimaged service already running"
    fi
    # install libfuse2t64 (libfuse2 on older systems) for legacy AppImages
    # https://github.com/AppImage/AppImageKit/wiki/FUSE
    local fuse2_lib=$(apt-cache search --names-only "^libfuse2" | cut -d ' ' -f 1)
    if ! dpkg -s "$fuse2_lib" &>/dev/null; then
      _info_msg "Installing $fuse2_lib for legacy AppImages"
      sudo apt-get update -qq && sudo apt-get install -qq "$fuse2_lib"
    fi
  fi

  # install nerdfont
  if [[ $(yq '.check.nerdfont | tag' "$CONFIG") == "!enabled" ]]; then
    local font=$(yq '.check.nerdfont' "$CONFIG")
    if [[ -z $(fc-list :family="$font NF") ]]; then
      if [[ ! -d "/usr/share/fonts/$font" ]]; then
        _info_msg "Downloading $font"
        sudo mkdir -p "/usr/share/fonts/$font"
        curl -sSL "https://github.com/ryanoasis/nerd-fonts/releases/latest/download/$font.tar.xz" \
          | sudo tar -xvJ -C "/usr/share/fonts/$font" &>/dev/null
      fi
      _info_msg "Reloading fc-cache"
      fc-cache -f
    else
      _info_msg "$font font already installed"
    fi
  fi
}

install() {
  _info_msg "Starting ${cozydot_txt} install"

  if [[ $(yq '.install.check' "$CONFIG") == true ]]; then check; fi

  # install apt packages
  if [[ $(yq '.install.apt | tag' "$CONFIG") == "!enabled" ]]; then
    local apt_pkgs
    mapfile -t apt_pkgs < <(yq '.install.apt[]' "$CONFIG")
    sudo apt-get update -qq
    for pkg in "${apt_pkgs[@]}"; do
      if ! dpkg -s "$pkg" &>/dev/null; then
        _info_msg "Installing $pkg"
        sudo apt-get install -qq "$pkg"
      fi
    done
  fi

  # install from 3rd-party repos
  if [[ $(yq '.install.addRepos | tag' "$CONFIG") == "!enabled" ]]; then
    _info_msg "Installing apt packages from third party repositories"

    # setting up signing keys & repo entries for source (repo)
    for ((i = 0; i < $(yq '.install.addRepos | length' "$CONFIG"); i++)); do
      local source_name=$(yq ".install.addRepos[$i].sourceName" "$CONFIG")
      local remote_key="$(yq ".install.addRepos[$i].remoteKey" "$CONFIG")"
      local key_path="$(yq ".install.addRepos[$i].keyPath" "$CONFIG")"
      local repo="$(yq ".install.addRepos[$i].repo" "$CONFIG")"

      # Eval string if subshell / var detected. Causes error if Bash special
      # characters used incorrectly
      if grep -Eq '\$(\(|\{).*(\)|\})' <<<"$remote_key"; then
        remote_key="$(eval echo "$remote_key")"
      fi

      # download asc key from remote
      if [[ $key_path == *.asc ]]; then
        _info_msg "Downloading .asc key for $source_name"
        sudo curl -sSL -o "$key_path" "$remote_key"
      # if key is a gpg file, then dearmor after downloading the key
      elif [[ $key_path == *.gpg ]]; then
        _info_msg "Downloading & dearmoring .gpg key for $source_name"
        curl -sSL "$remote_key" | sudo gpg --dearmor --yes -o "$key_path"
      fi

      # add repo entry into sources.list.d
      local source_file_path="/etc/apt/sources.list.d/$source_name.list"
      _info_msg "Adding repo entry for $source_name into sources.list.d"
      # TODO: check before eval echo
      sudo tee "$source_file_path" <<<"$(eval echo $repo)" >/dev/null

      # perform pinning to prioritise 3rd party if pinning entry exists
      if [[ $(yq ".install.addRepos[$i].pinning" "$CONFIG") != false ]]; then
        _info_msg "Performing pinning to prioritise $source_name"
        yq ".install.addRepos[$i].pinning" "$CONFIG" \
          | sudo tee "/etc/apt/preferences.d/$source_name" >/dev/null
      fi
    done

    # install packages
    local apt_pkgs
    mapfile -t apt_pkgs < <(yq '.install.addRepos[].packages[]' "$CONFIG")
    sudo apt-get update -qq
    for pkg in "${apt_pkgs[@]}"; do
      if ! dpkg -s "$pkg" &>/dev/null; then
        _info_msg "Installing third party package $pkg"
        sudo apt-get install -qq "$pkg"
      fi
    done
  fi

  # install flatpaks if flatpak is installed
  if [[ $(yq '.install.flatpak | tag' "$CONFIG") == "!enabled" ]] \
    && command -v flatpak &>/dev/null; then
    _info_msg "Installing flatpak packages"
    if ! flatpak remotes | grep -q ^flathub; then
      _info_msg "Adding flathub repository"
      flatpak remote-add --if-not-exists \
        flathub https://dl.flathub.org/repo/flathub.flatpakrepo
    fi
    # shellcheck disable=SC2046
    flatpak install -y flathub $(yq '.install.flatpak[]' "$CONFIG")
  fi

  # install cargo packages if cargo is installed
  if [[ $(yq '.install.cargo | tag' "$CONFIG") == "!enabled" ]] \
    && command -v cargo &>/dev/null; then
    _info_msg "Installing cargo packages"
    local rust_pkgs
    mapfile -t rust_pkgs < <(yq '.install.cargo[]' "$CONFIG")
    for pkg in "${rust_pkgs[@]}"; do
      if ! cargo install --list | grep -q "$(cut -d ' ' -f 1 <<<"$pkg")"; then
        # shellcheck disable=SC2086
        cargo install $pkg
      fi
    done
  fi

  # install binaries (AppImage / deb packages)
  if [[ $(yq '.install.binaries | tag' "$CONFIG") == "!enabled" ]]; then
    _info_msg "Installing binary packages"
    mkdir -p ~/Applications
    for ((i = 0; i < "$(yq '.install.binaries | length' "$CONFIG")"; i++)); do
      local binary_name=$(yq ".install.binaries[$i].name" "$CONFIG")
      local download_url=$(yq ".install.binaries[$i].url" "$CONFIG")
      # skip if binary / command (for .deb) exists
      if [[ -f "$HOME/Applications/$binary_name" ]] \
        || command -v "$(head -c '-5' <<<"$binary_name")" &>/dev/null; then
        _info_msg "$binary_name already exists"
        continue
      fi

      # downloading binary from url
      _info_msg "Downloading $binary_name"
      # eval string if subshell / variable detected
      if grep -Eq '\$(\(|\{).*(\)|\})' <<<"$download_url"; then
        download_url="$(eval echo "$download_url")"
      fi
      curl -sSL -o "$HOME/Applications/$binary_name" "$download_url"

      # install binary (AppImage / deb package)
      _info_msg "Installing $binary_name"
      if [[ $binary_name == *.AppImage ]]; then
        chmod +x "$HOME/Applications/$binary_name"
      elif [[ $binary_name == *.deb ]]; then
        sudo apt-get install -qq "$HOME/Applications/$binary_name"
        rm -f "$HOME/Applications/$binary_name"
      else
        _error_msg "Unsupported package: $binary_name. Only AppImage / deb is supported"
      fi
    done
  fi

  # install golang
  if [[ $(yq '.install.languages.goVersion | tag' "$CONFIG") == "!enabled" ]]; then
    _dl_golang "$(yq '.install.languages.goVersion' "$CONFIG")"
  fi

  # install nvm, node (& npm)
  if [[ $(yq '.install.languages.nodeVersion | tag' "$CONFIG") == "!enabled" ]]; then
    _dl_node "$(yq '.install.languages.nodeVersion' "$CONFIG")"
  fi

  _success_msg "Finished ${cozydot_txt} install. You may need to reload your shell with ${BLUE}. ~/.bashrc${NC} to use certain commands"
}

update() {
  _info_msg "Starting ${cozydot_txt} update"

  if [[ $(yq '.update.check' "$CONFIG") == true ]]; then check; fi

  if [[ $(yq '.update.apt | tag' "$CONFIG") == "!enabled" ]]; then
    _info_msg "Updating & upgrading apt packages"
    sudo apt-get -qq update && sudo apt-get -qq upgrade
    # upgrades the entire system, installing new packages if necessary, &
    # removes unused (orphaned) packages with their config files
    if [[ $(yq '.update.apt.aptFull' "$CONFIG") == true ]]; then
      _info_msg "Performing a full upgrade & removing uneeded packages & apt cache"
      sudo apt-get -qy dist-upgrade
      sudo apt-get -qy --purge autoremove
    fi
  fi

  # update flatpak
  if [[ $(yq '.update.flatpak' "$CONFIG") == true ]] \
    && command -v flatpak &>/dev/null; then
    _info_msg "Updating flatpaks"
    flatpak update -y
  fi

  # update rustup & cargo
  if [[ $(yq '.update.cargo' "$CONFIG") == true ]] \
    && command -v rustup &>/dev/null \
    && command -v cargo &>/dev/null; then
    _info_msg "Updating rustup $(rustup -V 2>/dev/null | cut -d ' ' -f 2) & cargo $(cargo -V | cut -d ' ' -f 2) packages"
    rustup update 2>/dev/null
    # install cargo-update package if not installed
    if ! cargo install --list | grep -q ^cargo-update; then
      _info_msg "Installing cargo-update required for updating rust packages"
      cargo install cargo-update
    fi
    cargo install-update -a
  fi

  # update yq
  if [[ $(yq '.update.other.yq' "$CONFIG") == true ]]; then
    local local_yq_ver=$(yq -V | cut -d ' ' -f 4)
    local latest_yq_ver=$(
      curl -sSL https://api.github.com/repos/mikefarah/yq/releases/latest \
        | yq '.tag_name'
    )
    if [[ $local_yq_ver != "$latest_yq_ver" ]]; then
      _info_msg "Downloading & installing latest yq (version $latest_yq_ver)"
      sudo curl -sSL -o /usr/bin/yq \
        https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
      sudo chmod +x /usr/bin/yq
    else
      _info_msg "yq $local_yq_ver is already the latest version"
    fi
  fi

  # update golang
  if [[ $(yq '.update.other.go' "$CONFIG") == true ]] \
    && command -v go &>/dev/null; then
    _dl_golang latest
  fi

  # update node if exists
  if [[ $(yq '.update.other.node' "$CONFIG") == true ]] \
    && [[ -f ~/.nvm/nvm.sh ]]; then
    _dl_node latest
  fi

  # delete all other Zellij sessions, including exited ones
  if [[ $(yq '.update.other.zellijClear' "$CONFIG") == true ]] \
    && command -v zellij &>/dev/null; then
    _info_msg "Deleting all other Zellij sessions"
    zellij delete-all-sessions -y
  fi

  _success_msg "Finished ${cozydot_txt} update"
}

configure() {
  _info_msg "Starting ${cozydot_txt} configuration"

  if [[ $(yq '.update.check' "$CONFIG") == true ]]; then check; fi

  # dotfile manager implementation via Stow
  if [[ $(yq '.configure.dotfiles | tag' "$CONFIG") == "!enabled" ]] \
    && command -v stow &>/dev/null; then
    _info_msg "Configuring dotfiles via Stow"
    local packages
    mapfile -t packages < <(yq -r '.configure.dotfiles.packages[]' "$CONFIG")
    for pkg in "${packages[@]}"; do
      _info_msg "Stowing dotfiles for $pkg"
      # Override option uses cozydot's dotfiles. Backup option does nothing (ie
      # uses original system dotfiles)
      if [[ $(yq -r '.configure.dotfiles.stowMode' "$CONFIG") == "override" ]]; then
        _info_msg "Overriding $pkg original dotfiles with ${cozydot_txt}'s dotfiles"
        # -T copies folder contents
        # --remove-destination is used to remove files in case files can't be
        #   read (eg symlinks) first
        cp -rT --remove-destination "dotfiles/$pkg" "$HOME"
      elif [[ $(yq -r '.configure.dotfiles.stowMode' "$CONFIG") == "backup" ]]; then
        _info_msg "Using system dotfiles as source of truth. ${cozydot_txt}'s dotfiles will be overwritten"
      fi
      # --no-folding stows individual files instead of directories
      # --adopt replaces cozydot's dotfiles with original system ones
      # Needed as Stow throws an error if system dotfiles exist. Cozydot's
      # dotfiles will be lost, but setting .stowMode to "override" fixes this
      stow --no-folding --adopt -d "dotfiles/" -t "$HOME" "$pkg"
    done
  fi

  # setup Alacritty adds desktop icon & entry
  if [[ $(yq '.configure.apps.alacritty' "$CONFIG") == true ]] \
    && command -v alacritty &>/dev/null; then
    if [[ ! -f /usr/share/pixmaps/Alacritty.svg ]]; then
      _info_msg "Adding Alacritty icon"
      sudo curl -sSL --create-dirs -o /usr/share/pixmaps/Alacritty.svg \
        https://github.com/alacritty/alacritty/raw/master/extra/logo/alacritty-term.svg
    fi

    if [[ ! -f /usr/share/applications/Alacritty.desktop ]]; then
      _info_msg "Adding desktop entry"
      sudo curl -sSL --create-dirs -o /usr/share/applications/Alacritty.desktop \
        https://github.com/alacritty/alacritty/raw/master/extra/linux/Alacritty.desktop
      sudo update-desktop-database
    fi
  fi

  # setup Docker adds user to docker group & uses local logging driver to prevent disk-exhaustion
  if [[ $(yq '.configure.apps.docker' "$CONFIG") == true ]] \
    && command -v docker &>/dev/null; then
    # https://docs.docker.com/engine/install/linux-postinstall
    # manage Docker as non-root user
    if ! getent group docker | grep "$USER" &>/dev/null; then
      _info_msg "Adding user to docker group to allow user to execute docker commands"
      sudo groupadd -f docker         # create Docker group
      sudo usermod -aG docker "$USER" # add user to Docker group
      # change group ID to Docker to activate change in current shell
      newgrp docker
    fi

    # use local logging driver to prevent disk-exhaustion. Local logging driver
    # performs log-rotation & compresses log files by default.
    # https://docs.docker.com/config/containers/logging/configure
    sudo touch /etc/docker/daemon.json
    if [[ "$(yq -r '.log-driver' /etc/docker/daemon.json)" != "local" ]]; then
      _info_msg "Using local logging driver to prevent disk-exhaustion"
      yq -n -o=j '{"log-driver": "local", "log-opts": {"max-size": "10m"}}' \
        | sudo tee /etc/docker/daemon.json >/dev/null
    fi
  elif [[ $(yq '.configure.apps.docker' "$CONFIG") == true ]]; then
    _warning_msg "Docker not installed, skipping..."
  fi

  # setup virtualbox adds user to vboxusers group
  if [[ $(yq '.configure.apps.virtualbox' "$CONFIG") == true ]] \
    && command -v virtualbox &>/dev/null; then
    # accesss USB devices https://www.virtualbox.org/manual/ch02.html#install-linux-vboxusers
    if ! getent group vboxusers | grep "$USER" &>/dev/null; then
      _info_msg "Adding user to vboxusers group to allow user to access USB devices"
      sudo groupadd -f vboxusers         # create vboxusers group
      sudo usermod -aG vboxusers "$USER" # add user to vboxusers group
      # change group ID to vboxusers to activate change in current shell
      newgrp vboxusers
    fi
  elif [[ $(yq '.configure.apps.virtualbox' "$CONFIG") == true ]]; then
    _warning_msg "virtualbox not installed, skipping..."
  fi

  # install vscode extensions
  if [[ $(yq '.configure.apps.vscodeExtensions | tag' "$CONFIG") == "!enabled" ]] \
    && command -v code &>/dev/null; then
    _info_msg "Installing vscode extensions"
    local extensions
    mapfile -t extensions < <(
      yq -r '.configure.apps.vscodeExtensions[]' "$CONFIG"
    )
    local installed_ext="$(code --list-extensions)"
    for ext in "${extensions[@]}"; do
      if ! grep -q "$ext" <<<"$installed_ext"; then
        code --install-extension "$ext"
      fi
    done
  elif [[ $(yq '.configure.apps.vscode.extensions | tag' "$CONFIG") == "!enabled" ]]; then
    _warning_msg "VSCode not installed, skipping..."
  fi

  # cinnamon desktop environment configurations
  if [[ $(yq '.configure.DECinnamon | tag' "$CONFIG") == "!enabled" ]] \
    && [[ $DESKTOP_ENVIRONMENT == "cinnamon" ]]; then
    if [[ $(yq '.configure.DECinnamon.defaultTerm | tag' "$CONFIG") == "!enabled" ]]; then
      local term=$(yq ".configure.DECinnamon.defaultTerm" "$CONFIG")
      _info_msg "Setting default terminal to $term"
      gsettings set org.cinnamon.desktop.default-applications.terminal exec "$term"
      gsettings set org.cinnamon.desktop.default-applications.terminal exec-arg ''
    fi
  fi

  # GNOME desktop environment configurations
  if [[ $(yq '.configure.DEGnome | tag' "$CONFIG") == "!enabled" ]] \
    && [[ "$DESKTOP_ENVIRONMENT" == "gnome" ]]; then
    # settings config increase screen blank delay to 15 mins, set dark mode
    if [[ $(yq '.configure.DEGnome.settings' "$CONFIG") == true ]]; then
      _info_msg "Configuring GNOME desktop environment"
      # increase screen blank delay to 15 mins (the max in UI)
      gsettings set org.gnome.desktop.session idle-delay 900
      # disable screen dimming (doesn't work with Power Saving mode)
      gsettings set org.gnome.settings-daemon.plugins.power idle-dim false
      # dark mode
      gsettings set org.gnome.desktop.interface color-scheme 'prefer-dark'
    fi

    # install gnome-tweaks & gnome-shell-extensions
    if ! command -v gnome-tweaks &>/dev/null \
      || ! command -v gnome-extensions &>/dev/null; then
      _info_msg "Installing gnome-tweaks & gnome-shell-extensions"
      sudo apt-get update -qq && sudo apt-get install -qq gnome-tweaks gnome-shell-extensions
    fi

    # install GNOME extensions
    if [[ $(yq '.configure.DEGnome.extensions | tag' "$CONFIG") == "!enabled" ]]; then
      # download & install GNOME extensions
      local exts
      mapfile -t exts < <(yq '.configure.DEGnome.extensions[]' "$CONFIG")
      for ext in "${exts[@]}"; do
        if ! gnome-extensions list | grep -q "$ext"; then
          _info_msg "Downloading GNOME extension $(cut -d "@" -f 1 <<<"$ext")"
          local ver=$(
            curl -sSL "https://extensions.gnome.org/extension-info/?uuid=$ext" \
              | yq '[.shell_version_map[].version] | max'
          )
          curl -sSL -o "/tmp/$ext.zip" \
            "https://extensions.gnome.org/extension-data/$(tr -d @ <<<"$ext").v$ver.shell-extension.zip"
          gnome-extensions install --force "/tmp/$ext.zip"
          _warning_msg "Please relogin in a new session for GNOME to enable $(cut -d "@" -f 1 <<<"$ext") extension"
        else
          _info_msg "Enabling extension $ext"
          gnome-extensions enable "$ext"
        fi
      done
    fi

    # set default terminal
    if [[ $(yq '.configure.DEGnome.defaultTerm | tag' "$CONFIG") == "!enabled" ]]; then
      local term=$(yq ".configure.DEGnome.defaultTerm" "$CONFIG")
      _info_msg "Setting default terminal to $term"
      # Ubuntu has a dedicated terminal key, so we just need to set (not add) a keyboard shortcut
      if gsettings get org.gnome.settings-daemon.plugins.media-keys terminal &>/dev/null; then
        gsettings set org.gnome.desktop.default-applications.terminal exec "$term"
        gsettings set org.gnome.desktop.default-applications.terminal exec-arg ''
      else
        _info_msg "Adding terminal keyboard shortcut to ${BLUE}<Primary><Alt>T${NC}"
        dconf write /org/gnome/settings-daemon/plugins/media-keys/custom-keybindings \
          "['/org/gnome/settings-daemon/plugins/media-keys/custom-keybindings/custom0/']"
        dconf write /org/gnome/settings-daemon/plugins/media-keys/custom-keybindings/custom0/name "'Terminal'"
        dconf write /org/gnome/settings-daemon/plugins/media-keys/custom-keybindings/custom0/command "'$term'"
        dconf write /org/gnome/settings-daemon/plugins/media-keys/custom-keybindings/custom0/binding "'<Primary><Alt>T'"
      fi
    fi

    # make Dash to Dock mimic MacOS dock behaviour
    # default settings: https://github.com/micheleg/dash-to-dock/blob/master/schemas/org.gnome.shell.extensions.dash-to-dock.gschema.xml
    if [[ $(yq '.configure.DEGnome.MacOSDock' "$CONFIG") == true ]] \
      && gnome-extensions list | grep -Eq 'dash-to-dock|ubuntu-dock'; then
      _info_msg "Making Dash to Dock mimic MacOS dock behaviour"
      # modify position & size
      dconf write /org/gnome/shell/extensions/dash-to-dock/dock-position "'BOTTOM'"
      dconf write /org/gnome/shell/extensions/dash-to-dock/dash-max-icon-size 32
      # hide dock
      dconf write /org/gnome/shell/extensions/dash-to-dock/dock-fixed false
      # show dock on mouse hover
      dconf write /org/gnome/shell/extensions/dash-to-dock/autohide true
      dconf write /org/gnome/shell/extensions/dash-to-dock/require-pressure-to-show false
      # show dock when it doesn't obstruct focused application
      dconf write /org/gnome/shell/extensions/dash-to-dock/intellihide true
      dconf write /org/gnome/shell/extensions/dash-to-dock/intellihide-mode "'FOCUS_APPLICATION_WINDOWS'"
      # disable panel mode
      dconf write /org/gnome/shell/extensions/dash-to-dock/extend-height false
      # minimize on click when application is opened
      dconf write /org/gnome/shell/extensions/dash-to-dock/click-action "'minimize-or-previews'"
    elif [[ $(yq ".configure.DEGnome.MacOSDock" "$CONFIG") == true ]]; then
      _warning_msg "Dash to Dock extension not installed"
    fi

    # smoothen corners in Rounded Window Corners Reborn
    # default settings: https://github.com/flexagoon/rounded-window-corners/blob/main/resources/schemas/org.gnome.shell.extensions.rounded-window-corners-reborn.gschema.xml
    if [[ $(yq '.configure.DEGnome.smoothRoundedCorners' "$CONFIG") == true ]] \
      && gnome-extensions list | grep -q rounded-window-corners; then
      _info_msg "Smoothen corners in Rounded Corners extension"
      dconf write /org/gnome/shell/extensions/rounded-window-corners-reborn/global-rounded-corner-settings \
        "{'padding': <{'left': uint32 1, 'right': 1, 'top': 1, 'bottom': 1}>, \
          'keepRoundedCorners': <{'maximized': false, 'fullscreen': false}>, \
          'borderRadius': <uint32 16>, 'smoothing': <0.5>, \
          'borderColor': <(0.5, 0.5, 0.5, 1.0)>, 'enabled': <true>}"
    elif [[ $(yq ".configure.DEGnome.smoothRoundedCorners" "$CONFIG") == true ]]; then
      _warning_msg "Rounded Corners extension not installed"
    fi
  fi

  _success_msg "Finished ${cozydot_txt} configuration. You may need to run ${BLUE}. ~/.bashrc${NC} if commands aren't recognised"
}

# ----- MAIN -----

main() {
  colours true # PRINT FUNCTIONS

  # Make this script an executable by creating symlink to /usr/local/bin.
  # script path must be ~/.cozydot/cozydot for standardisation
  if [[ ! -L /usr/local/bin/cozydot ]]; then
    if [[ $(realpath "$0") != "/home/$USER/.cozydot/cozydot" ]]; then
      _info_msg "Moving cozydot to ~/.cozydot"
      mv "$(dirname "$(realpath "$0")")" ~/.cozydot/
    fi
    sudo cp -s --remove-destination ~/.cozydot/cozydot /usr/local/bin/cozydot
    _success_msg "Created symlink for cozydot. Run $cozydot_txt as a command anywhere after this"
    exit
  fi

  if ! command -v curl &>/dev/null; then
    _info_msg "Installing curl" # NOTE: do not update curl to save time
    sudo apt-get install -qq curl
  fi

  if ! command -v yq &>/dev/null; then
    _info_msg "Installing yq" # NOTE: do not update yq to save time
    sudo curl -sSL -o /usr/bin/yq \
      https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
    sudo chmod +x /usr/bin/yq
  fi

  [[ $# -gt 0 ]] || { _usage && _error_msg "No argument(s)"; }

  while [[ $# -gt 0 ]]; do
    case $1 in
      -h | --help) _usage && exit ;;
      # OPTIONS
      -n | --no-colour) colours false ;;
      -c | --config)
        set_config "$2"
        shift
        ;;
      --list-configs) list_configs ;;
      -V | --version) get_version ;;
      # COMMANDS
      check) _set_global_var && check ;;
      i | install) _set_global_var && install ;;
      u | update) _set_global_var && update ;;
      c | configure) _set_global_var && configure ;;
      *) _usage && _error_msg "Invalid argument(s)" ;;
    esac
    shift
  done
}

main "$@"
